<!-- ============================================================
  VERSIONING REMINDER (READ BEFORE CHANGING CODE)
  ------------------------------------------------------------
  When making ANY functional change:

  1) Update APP_VERSION below
     - Controls localStorage key (groceryApp_v##)
     - Prevents data/version confusion

  2) Update the visible build label in the header (optional but recommended)
     - Helps humans confirm the correct build is loaded

  3) Update VERSION in sw.js
     - Forces Service Worker + cache refresh

  4) Commit ALL related files together

  If you forget step #3, the browser may keep serving old code.
============================================================ -->

<!-- =========================
     index.html  (BUILD 069)
     ========================= -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grocery APP</title>
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    html, body { overflow-x: hidden; margin:0; }
    * { box-sizing: border-box; }

    :root{
      /* Core palette (warmer + friendlier) */
      --navy:#0b1220;

      /* ‚ÄúApp language‚Äù colors */
      --primary:#2563eb;
      --primary2:#1d4ed8;
      --success:#16a34a;
      --success2:#15803d;
      --scan:#f59e0b;
      --scan2:#d97706;
      --danger:#ef4444;
      --danger2:#dc2626;

      /* Softer neutrals */
      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --soft:#f3f1ff;
      --soft2:#eef2ff;

      --border:rgba(15,23,42,.10);
      --shadow: 0 10px 26px rgba(2,6,23,.10);
      --shadow2: 0 14px 34px rgba(2,6,23,.12);

      --r-lg: 22px;
      --r-md: 18px;
      --r-pill: 999px;
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      background: linear-gradient(180deg, #fbfbff 0%, #f3f1ff 45%, #eef2ff 100%);
      color: var(--ink);
    }

    header{
      padding:14px 16px;
      background: linear-gradient(90deg, #0b1220 0%, #111827 55%, #0b1220 100%);
      color:#fff;
      font-weight:800;
      font-size:18px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      letter-spacing: .3px;
    }

    .wrap { padding:16px 14px 90px; max-width:820px; margin:0 auto; }

    /* Tabs row */
    .tabs{
      display:flex;
      gap:12px;
      margin-bottom:14px;
      align-items:center;
      flex-wrap:wrap;
    }

    .tabBtn{
      background: linear-gradient(180deg, #f4f2ff 0%, #ecebff 100%);
      color: var(--ink);
      border-radius: var(--r-pill);
      padding: 12px 20px;
      font-weight: 900;
      border: 1px solid rgba(15,23,42,.12);
      box-shadow: none;
      cursor:pointer;
    }

    .tabBtn.active{
      background: linear-gradient(180deg, #111827 0%, #0b1220 100%);
      color:#fff;
      border: 0;
      box-shadow: 0 12px 22px rgba(2,6,23,.18);
    }

    /* Push right-side buttons to the edge */
    #btnClearDone{ margin-left:auto; }
    #btnMore{
      padding: 10px 14px;
      border-radius: var(--r-pill);
      font-weight: 900;
      line-height: 1;
      min-width: 48px;
    }

    /* Base row */
    .row { display:flex; gap:12px; flex-wrap:wrap; }

    /* ACTION row (Groceries main buttons) should fill width */
    .actionRow{
      justify-content: space-between;
    }
    .actionRow button{
      flex: 1 1 150px;  /* grows to fill, wraps nicely */
      min-width: 140px;
    }

    button{
      appearance:none;
      border:0;
      border-radius: var(--r-md);
      padding: 14px 18px;
      font-size: 16px;
      font-weight: 900;
      cursor: pointer;
      color:#fff;
      background: linear-gradient(180deg, var(--primary) 0%, var(--primary2) 100%);
      box-shadow: var(--shadow);
      transition: transform .08s ease, filter .12s ease, box-shadow .12s ease;
      letter-spacing: .2px;
    }

    /* ===== SHOP dropdown (add BELOW button{}) ===== */
    .shopWrap{
      position: relative;
      display: inline-block;
      margin-left: 20px;   /* space between UNDO and SHOP */
    }

    .shopMenu{
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 180px;
      padding: 8px;
      background: #fff;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      z-index: 9999;
    }

    .shopMenu.hidden{ display: none; }

    .shopItem{
      width: 100%;
      padding: 10px 12px;
      text-align: left;
      border: 0;
      background: transparent;
      cursor: pointer;
      color: #000;           /* ‚úÖ FIX: always visible text */
    }

    .shopItem:hover{ background: rgba(0,0,0,.08); }

    button:active{ transform: translateY(1px); }
    button:hover{ filter: brightness(1.03); box-shadow: var(--shadow2); }
    button:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; filter:none; }

    button.secondary{
      background: linear-gradient(180deg, #f4f2ff 0%, #ecebff 100%);
      color: var(--ink);
      border: 1px solid rgba(15,23,42,.12);
      box-shadow: 0 10px 18px rgba(2,6,23,.06);
    }

    button.danger{
      background: linear-gradient(180deg, var(--danger) 0%, var(--danger2) 100%);
      color:#fff;
      box-shadow: 0 12px 22px rgba(239,68,68,.16);
    }

    /* Intent colors */
    button.scanQR{
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
    }
    button.scanUPC{
      background: linear-gradient(180deg, var(--scan) 0%, var(--scan2) 100%);
      box-shadow: 0 10px 18px rgba(245,158,11,.22);
    }

    #btnUndo{
      min-width: 60px !important;
      padding-left: 6px;
      padding-right: 6px;
      background: linear-gradient(180deg, #a78bfa 0%, #7c3aed 100%) !important;
      color:#fff !important;
      border:0 !important;
      box-shadow: 0 12px 22px rgba(124,58,237,.18) !important;
    }

    #btnAdd{
      background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%) !important;
      color:#fff !important;
      border:0 !important;
      box-shadow: 0 12px 22px rgba(34,197,94,.18) !important;
    }
    #btnMasterAddSelected{
      background: linear-gradient(180deg, #14b8a6 0%, #0d9488 100%) !important;
      color:#fff !important;
      border:0 !important;
      box-shadow: 0 12px 22px rgba(20,184,166,.18) !important;
    }

    .card{
      background: var(--card);
      border-radius: var(--r-lg);
      padding:12px;
      margin-top:12px;
      border: 1px solid rgba(15,23,42,.08);
      box-shadow: 0 16px 34px rgba(2,6,23,.10);
    }

    .muted { color: var(--muted); }
    .spacer { height:10px; }
    .total { font-weight:900; font-size:18px; letter-spacing:.2px; }

    /* Rows / pills */
    .pill,
    .catPill{
      font-size:12px; font-weight:900;
      padding:6px 10px; border-radius:999px;
      background:#e5e7eb; color:#111827;
      white-space:nowrap;
      border: 1px solid rgba(15,23,42,.10);
    }
    .pill.ok{ background:rgba(34,197,94,.18); color:#065f46; }
    .pill.warn{ background:rgba(245,158,11,.18); color:#92400e; }

    /* Grocery list rows */
    .item {
      display:flex; align-items:center; gap:10px;
      padding:10px 6px; border-bottom:1px solid #eee;
    }
    .item:last-child { border-bottom:0; }
    .check { width:26px; height:26px; }
    .name { flex:1; font-size:16px; cursor:pointer; }
    .done .name { text-decoration: line-through; opacity:.55; }
    .qty { width:64px; padding:8px 10px; border:1px solid #ddd; border-radius:12px; font-size:16px; }
    select { padding:8px 10px; border:1px solid #ddd; border-radius:12px; font-size:16px; background:#fff; }
    .price { width:96px; padding:8px 10px; border:1px solid #ddd; border-radius:12px; font-size:16px; }

    /* Master list rows */
    .masterRow{
      display:flex; align-items:center; gap:10px;
      padding:10px 6px; border-bottom:1px solid #eee;
    }
    .masterRow:last-child{ border-bottom:0; }
    .mName{ flex:1; font-size:16px; cursor:pointer; font-weight:800; }
    .mCheck{ width:26px; height:26px; }

    /* Dish rows */
    .dishRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 6px; border-bottom:1px solid #eee;
    }
    .dishRow:last-child{ border-bottom:0; }
    .dishName{ font-size:16px; font-weight:800; cursor:pointer; }

    /* Row delete buttons: soft danger */
    .delBtn{
      background: rgba(239,68,68,.10);
      color:#7f1d1d;
      padding:10px 12px;
      border-radius: 14px;
      font-weight: 900;
      box-shadow:none;
      border: 1px solid rgba(239,68,68,.18);
    }
    .delBtn:hover{ filter: brightness(1.02); }

    /* Scanner modal */
    .modalBg {
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:16px;
      z-index: 9999;
    }
    .modal {
      width:min(760px, 100%);
      max-width: calc(100vw - 32px);
      background:#fff; border-radius:18px; overflow:hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
      max-height: calc(100dvh - 32px);
      display:flex; flex-direction:column;
    }
    .modalHead {
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px; background:#111827; color:#fff;
    }
    .modalBody {
      padding:12px; display:flex; flex-direction:column; gap:10px;
      overflow-y:auto; overscroll-behavior: contain;
      padding-bottom: env(safe-area-inset-bottom, 12px);
    }
    #reader {
      width:100%; max-height:50dvh; overflow:hidden; border-radius:16px; background:#000;
    }
    #reader * { max-width:100% !important; box-sizing:border-box; }
    #reader video,
    #reader canvas {
      width:100% !important; height:auto !important;
      max-height:50dvh !important; object-fit:contain;
      border-radius:16px; display:block;
    }
    .hint { color:#6b7280; font-size:14px; margin-top:0; }
    .scanBar {
      margin-top:10px; background:rgba(17,24,39,.06);
      border:1px solid rgba(17,24,39,.10); border-radius:14px;
      padding:10px 12px; display:flex; align-items:center;
      justify-content:space-between; gap:10px; flex-wrap:wrap;
      position:sticky; bottom:0; z-index:5; background:#fff;
      box-shadow:0 -6px 18px rgba(0,0,0,.06);
    }
    .scanMsg {
      font-weight:900; font-size:16px; color:#111827;
      flex:1; min-width:0; overflow-wrap:anywhere;
    }
    .scanMsg.ok { color:#065f46; }
    .scanMsg.warn { color:#92400e; }
    .scanBtns { display:flex; gap:10px; flex-wrap:wrap; flex:0 0 auto; }
    .capBtn { background:#16a34a; }
    .doneBtn { background:#e5e7eb; color:#111827; }

    /* Add/Edit modal */
    .miniBg{
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:16px;
      z-index: 9998;
    }
/* ===== CATS modal: allow scrolling inside the modal ===== */
#catBg .mini{
  max-height: calc(100dvh - 32px);   /* fits on screen */
  display: flex;
  flex-direction: column;
  overflow: hidden;                 /* keep rounded corners clean */
}

/* Make the content area the scroll container */
#catBg .miniBody{
  overflow-y: auto;
  -webkit-overflow-scrolling: touch; /* iPhone smooth scrolling */
  flex: 1 1 auto;
  min-height: 0;                     /* IMPORTANT for flex scrolling */
}

/* Optional: keep buttons visible */
#catBg .miniBtns{
  flex: 0 0 auto;
}

    /* PHASE 2: Ingredient rows inside Dish modal */
    .ingRow{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .ingRow input{
      flex:1;
      padding:12px 12px;
      border:1px solid #ddd;
      border-radius:14px;
      font-size:16px;
    }
    .ingRow select{
      width:160px;
      padding:12px 12px;
      border:1px solid #ddd;
      border-radius:14px;
      font-size:16px;
      background:#fff;
    }
    .ingRow .delBtn{ padding:10px 12px; }

    .mini{
      width:min(560px, 100%);
      background:#fff; border-radius:18px; overflow:hidden;
      box-shadow:0 20px 60px rgba(0,0,0,.35);
    }
    .miniHead{
      padding:12px 14px; background:#111827; color:#fff;
      display:flex; justify-content:space-between; align-items:center;
      font-weight:900;
    }
    .miniBody{ padding:12px 14px; display:flex; flex-direction:column; gap:10px; }
    .miniRow{ display:flex; flex-direction:column; gap:6px; }
    .miniRow label{ font-weight:900; color:#111827; }
    .miniRow input, .miniRow select{
      width:100%; padding:12px 12px; border:1px solid #ddd;
      border-radius:14px; font-size:16px;
    }
    .miniBtns{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; padding:0 14px 14px; }

    /* Tools screen */
    .toolRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .toolRow button{ flex: 1 1 220px; min-width: 200px; }
    .smallNote{ font-size: 13px; color: var(--muted); line-height: 1.35; }
    .reportBox{
      white-space: pre-wrap;
      background: rgba(17,24,39,.04);
      border: 1px solid rgba(17,24,39,.10);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 13px;
      color: #111827;
    }
    .toggleRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding: 10px 12px;
      border: 1px solid rgba(15,23,42,.10);
      border-radius: 14px;
      background: rgba(255,255,255,.7);
    }
    .toggleRow label{
      display:flex; align-items:center; gap:10px;
      font-weight: 900;
    }
    .toggleRow input[type="checkbox"]{ width: 22px; height: 22px; }

    /* ===== Category Manager ===== */
    .catMgrList{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding: 6px 0 4px;
    }
    .catMgrRow{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px;
      border:1px solid rgba(15,23,42,.12);
      border-radius:14px;
      background: rgba(17,24,39,.03);
    }
    .dragHandle{
      width:34px;
      text-align:center;
      user-select:none;
      cursor: grab;
      font-weight: 900;
      opacity:.75;
      border:1px solid rgba(15,23,42,.10);
      border-radius:12px;
      padding:8px 8px;
      background:#fff;
    }
    .catMgrRow.dragging{
      opacity:.55;
      transform: scale(0.995);
    }
    .catNameInput{
      flex:1;
      padding:12px 12px;
      border:1px solid #ddd;
      border-radius:14px;
      font-size:16px;
      background:#fff;
      font-weight:900;
    }
    .catBadge{
      font-size: 12px;
      font-weight: 900;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.12);
      background:#fff;
      color:#111827;
      white-space:nowrap;
      opacity:.8;
    }
    .catBadge.builtIn{
      background: rgba(37,99,235,.12);
      border-color: rgba(37,99,235,.18);
      color:#1d4ed8;
    }
    .catBadge.custom{
      background: rgba(34,197,94,.14);
      border-color: rgba(34,197,94,.18);
      color:#065f46;
    }
    @supports not (height: 100dvh){
    #catBg .mini{
      max-height: calc(100vh - 32px);
    }
  }
  </style>

  <script src="https://unpkg.com/html5-qrcode"></script>
</head>

<body>
  <header>Grocery APP <span style="opacity:.7;font-weight:600;">(Build 069)</span></header>

  <div class="wrap">
    <div class="tabs">
      <button id="tabGroceries" class="tabBtn active">Groceries</button>
      <button id="tabDishes" class="tabBtn">Dishes</button>

      <!-- ‚ãØ More button (Groceries -> Tools) -->
      <button id="btnMore" class="secondary" title="More / Import / Export">‚ãØ</button>

      <button id="btnClearDone" class="secondary">Clear Purchased</button>
    </div>

    <!-- GROCERIES TAB -->
    <div id="screenGroceries">
      <div class="row actionRow">
        <button id="btnNew">New List</button>
        <button id="btnScan" class="scanQR">SCAN QR</button>
        <button id="btnScanUPC" class="scanUPC">SCAN UPC</button>
        <button id="btnAdd" class="secondary">Add Item</button>
        <button id="btnUndo" class="secondary">Undo</button>
        <button id="btnCats" class="secondary" title="Manage Categories">CATS</button>

        <!-- SHOP button + dropdown -->
        <div class="shopWrap">
          <button id="btnShop" class="secondary">SHOP</button>
          <div id="shopMenu" class="shopMenu hidden" role="menu" aria-label="Shop links">
            <button class="shopItem" data-url="https://www.walmart.com/" role="menuitem">Walmart</button>
            <button class="shopItem" data-url="https://www.publix.com/" role="menuitem">Publix</button>
            <button class="shopItem" data-url="https://www.kroger.com/" role="menuitem">Kroger</button>
            <button class="shopItem" data-url="https://www.ingles-markets.com/" role="menuitem">Ingles</button>
          </div>
        </div>
      </div>

      <!-- Shopping list summary -->
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div>
            <b>Shopping List:</b> <span id="listName">Today</span><br>
            <span class="muted">Sorted by category walking order + name.</span>
          </div>
          <div class="total">Total: $<span id="total">0.00</span></div>
        </div>
      </div>

      <!-- Shopping list card FIRST (above Master) -->
      <div class="card" id="listCard"></div>

      <!-- Master list AFTER shopping list -->
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div>
            <b>Master Grocery List:</b>
            <span class="pill"><span id="masterCount">0</span> items</span>
          </div>
          <div class="muted">Check items here, then tap <b>ADD SELECTED</b>.</div>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <button id="btnMasterAddSelected" class="secondary">ADD SELECTED</button>
          <button id="btnMasterClearChecks" class="secondary">CLEAR CHECKS</button>
          <button id="btnMasterClear" class="danger">Clear Master</button>
        </div>

        <div class="spacer"></div>
        <div id="masterCard"></div>
      </div>
    </div>

    <!-- DISHES TAB -->
    <div id="screenDishes" style="display:none;">
      <div class="row">
        <button id="btnScanDish">SCAN DISH</button>
        <button id="btnAddDish" class="secondary">Add Dish</button>
        <button id="btnRandom14" class="secondary">Random Menu (14)</button>
        <button id="btnAddCheckedIng" class="secondary">Add ING. To Shopping List</button>
        <button id="btnClearMenu" class="secondary">Clear Menu</button>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div><b>Current Menu:</b> <span class="pill ok"><span id="menuCount">0</span> dishes</span></div>
          <div class="muted">Scanning a dish adds it to Menu + Catalog.</div>
        </div>
      </div>
      <div class="card" id="menuCard"></div>

      <!-- Dish Catalog card with Clear Catalog inside it -->
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div><b>Dish Catalog:</b> <span class="pill"><span id="catalogCount">0</span> total</span></div>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
            <div class="muted">Tap a dish to rename; delete button removes menu/catalog.</div>
            <button id="btnClearCatalog" class="danger">Clear Catalog</button>
          </div>
        </div>

        <div class="spacer"></div>
        <div id="catalogCard"></div>
      </div>
    </div>

    <!-- TOOLS / IMPORT EXPORT SCREEN -->
    <div id="screenTools" style="display:none;">
      <div class="row">
        <button id="btnToolsBack" class="secondary">‚Üê Back</button>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div><b>More / Tools</b></div>
          <div class="muted">Export/Import for multi-device manual sync.</div>
        </div>

        <div class="spacer"></div>

        <div class="miniRow">
          <label for="deviceName">Device name (included in export file)</label>
          <input id="deviceName" type="text" placeholder="e.g., Dave-iPhone, Kitchen-iPad, Laptop" />
          <div class="smallNote">Tip: Use a unique name per device so you can tell exports apart.</div>
        </div>

        <div class="spacer"></div>
        <button id="btnCatsTools" class="secondary" type="button">Manage Categories</button>
        <div class="smallNote">Categories are stored locally per device. You can optionally export/import them via Export ALL.</div>
      </div>

      <div class="card">
        <b>Export</b>
        <div class="spacer"></div>
        <div class="toolRow">
          <button id="btnExportAll" class="secondary">Export ALL (recommended)</button>
          <button id="btnExportMaster" class="secondary">Export Master Groceries</button>
          <button id="btnExportDishes" class="secondary">Export Dish Catalog</button>
          <button id="btnExportUPC" class="secondary">Export UPC DB</button>
        </div>
        <div class="spacer"></div>
        <div class="smallNote">
          Export creates a JSON file you can AirDrop/email/text to your other device, then import there.
        </div>
      </div>

      <div class="card">
        <b>Import (MERGE)</b>
        <div class="spacer"></div>

        <div class="toggleRow">
          <label><input id="impOverwriteUPC" type="checkbox"> Overwrite UPC conflicts (default: skip conflicts)</label>
        </div>

        <div class="toggleRow">
          <label><input id="impMergeCats" type="checkbox" checked> Merge categories (from Export ALL only)</label>
        </div>

        <div class="spacer"></div>

        <div class="toolRow">
          <button id="btnImport" class="secondary">Import JSON (merge)</button>
        </div>

        <input id="importFile" type="file" accept=".json,application/json" style="display:none;" />

        <div class="spacer"></div>
        <div class="reportBox" id="importReport">No import yet.</div>
      </div>
    </div>
  </div>

  <!-- Scanner Modal -->
  <div class="modalBg" id="modalBg">
    <div class="modal">
      <div class="modalHead">
        <div><b id="scanTitle">Scan</b></div>
        <button id="btnCloseTop" class="secondary" style="padding:10px 12px; border-radius:12px;">Close</button>
      </div>
      <div class="modalBody">
        <div id="reader"></div>
        <div class="scanBar">
          <div id="scanMsg" class="scanMsg">Point camera at code ‚Äì hold steady‚Ä¶</div>
          <div class="scanBtns">
            <button id="btnCapture" class="capBtn" disabled>CAPTURE</button>
            <button id="btnDone" class="doneBtn">DONE</button>
          </div>
        </div>
        <div class="hint" id="scanHint">
          Tip: Fill the capture box with the code and hold steady.
        </div>
      </div>
    </div>
  </div>

  <!-- Add/Edit Item Modal -->
  <div class="miniBg" id="miniBg">
    <div class="mini">
      <div class="miniHead">
        <div id="miniTitle">Add Item</div>
        <button id="miniClose" class="secondary" style="padding:10px 12px; border-radius:12px;">X</button>
      </div>
      <div class="miniBody">
        <div class="miniRow">
          <label for="miniName">Item name</label>
          <input id="miniName" type="text" placeholder="e.g., Milk" />
        </div>
        <div class="miniRow">
          <label for="miniCat">Category</label>
          <select id="miniCat"></select>
        </div>
      </div>
      <div class="miniBtns">
        <button id="miniCancel" class="secondary">Cancel</button>
        <button id="miniOk">OK</button>
      </div>
    </div>
  </div>

  <!-- Category Manager Modal -->
  <div class="miniBg" id="catBg" style="display:none;">
    <div class="mini">
      <div class="miniHead">
        <div>Manage Categories</div>
        <button id="catCloseX" class="secondary" style="padding:10px 12px; border-radius:12px;">X</button>
      </div>
      <div class="miniBody">
        <div class="muted" style="font-size:14px;">
          Drag to reorder (walking order). Rename any category. Delete custom categories (items move to Misc).
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <input id="catNewName" type="text" placeholder="New category name‚Ä¶" style="flex:1; min-width:220px; padding:12px; border:1px solid #ddd; border-radius:14px; font-size:16px;">
          <button id="catAddBtn" class="secondary" type="button" style="min-width:160px;">+ Add Category</button>
        </div>

        <div class="catMgrList" id="catMgrList"></div>
      </div>
      <div class="miniBtns">
        <button id="catCancel" class="secondary" type="button">Close</button>
        <button id="catSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- Dish Ingredients Modal (PHASE 2) -->
  <div class="miniBg" id="dishBg" style="display:none;">
    <div class="mini">
      <div class="miniHead">
        <div id="dishTitle">Dish Ingredients</div>
        <button id="dishClose" class="secondary" style="padding:10px 12px; border-radius:12px;">X</button>
      </div>

      <div class="miniBody" style="gap:12px;">
        <div class="muted" style="font-size:14px;">
          Add ingredients for this dish. These will be used when you ‚ÄúAdd ING. To Shopping List‚Äù.
        </div>

        <div id="dishIngList" style="display:flex; flex-direction:column; gap:10px;"></div>

        <button id="dishAddIng" class="secondary" type="button">+ Add Ingredient</button>
      </div>

      <div class="miniBtns">
        <button id="dishCancel" class="secondary" type="button">Cancel</button>
        <button id="dishSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <script>
  // =========================
  // Consistency: Build / Version
  // =========================
  const APP_VERSION = 69;

  // =========================
  // Smart one-time migration helper
  // =========================
  function smartMigrateLocalStorage({ maxLookback = 25 } = {}) {
    const newKey = `groceryApp_v${APP_VERSION}`;
    const flagKey = `groceryApp_migrated_to_${newKey}`;

    if (localStorage.getItem(newKey)) return false;
    if (localStorage.getItem(flagKey) === "1") return false;

    for (let v = APP_VERSION - 1; v >= Math.max(1, APP_VERSION - maxLookback); v--) {
      const oldKey = `groceryApp_v${v}`;
      const oldData = localStorage.getItem(oldKey);
      if (!oldData) continue;

      try {
        JSON.parse(oldData);
        localStorage.setItem(newKey, oldData);
        localStorage.setItem(flagKey, "1");
        console.log(`[MIGRATE] Copied ${oldKey} -> ${newKey}`);
        return true;
      } catch (e) {
        console.warn(`[MIGRATE] Invalid data in ${oldKey}, skipping`, e);
      }
    }
    return false;
  }

  smartMigrateLocalStorage();

  // Service worker registration
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("sw.js").catch(console.warn);
  }

  // =========================
  // Build constants
  // =========================
  const LS_KEY = `groceryApp_v${APP_VERSION}`;
  const UNITS = ["ea","lb","oz","gal","ct"];

  // ===== DEFAULT categories shipped with the app =====
  // Stable IDs + labels. Users can add/rename/reorder locally.
  const DEFAULT_CATS = [
    { id:"produce", label:"Produce" },
    { id:"deli", label:"Deli" },
    { id:"bakery", label:"Bakery" },
    { id:"seafood", label:"Seafood" },
    { id:"beef", label:"Beef" },
    { id:"pork", label:"Pork" },
    { id:"chicken", label:"Chicken" },
    { id:"dairy", label:"Dairy" },
    { id:"cheese", label:"Cheese" },
    { id:"beerwine", label:"Beer/Wine" },
    { id:"beverages", label:"Beverages" },
    { id:"snacks", label:"Snacks" },
    { id:"frozen", label:"Frozen" },
    { id:"household", label:"Household" },
    { id:"baking", label:"Baking" },
    { id:"canveggies", label:"Can Vegies" },
    { id:"canmeat", label:"Can Meat" },
    { id:"condiments", label:"Condiments" },
    { id:"bread", label:"Bread" },
    { id:"pet", label:"Pet" },
    { id:"pharmacy", label:"Pharmacy" },
    { id:"misc", label:"Misc" } // IMPORTANT fallback
  ];

  // =========================
  // Helpers
  // =========================
  function loadState() {
    try { return JSON.parse(localStorage.getItem(LS_KEY)) || null; }
    catch { return null; }
  }
  function saveState(s) { localStorage.setItem(LS_KEY, JSON.stringify(s)); }
  function newBlankList(name) { return { name, items: [], created: Date.now() }; }
  function money(n) { return (Math.round((n||0)*100)/100).toFixed(2); }

  function generateId() {
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }

  function escapeHtml(s) {
    return String(s ?? "").replace(/[&<>"']/g, m => ({
      "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;"
    }[m]));
  }

  function normName(s){ return String(s ?? "").trim().replace(/\s+/g, " "); }

  // stable slug for custom category IDs
  function slugify(s){
    s = normName(s).toLowerCase();
    s = s.replace(/&/g,"and");
    s = s.replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"");
    if(!s) s = "cat";
    return s.slice(0,32);
  }

  function showToast(message, duration = 2000) {
    const div = document.createElement('div');
    div.textContent = message;
    div.style.cssText = `
      position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
      background: #111827; color: white; padding: 12px 24px;
      border-radius: 12px; z-index: 10000; font-weight: 700;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25); pointer-events: none;
      max-width: calc(100vw - 24px); text-align:center;
    `;
    document.body.appendChild(div);
    setTimeout(() => div.remove(), duration);
  }

  function computeTotal() {
    return state.current.items.reduce((sum, it) => {
      const p = parseFloat(it.price) || 0;
      const q = parseFloat(it.qty) || 1;
      return sum + p * q;
    }, 0);
  }

  // =========================
  // State
  // =========================
  let state = loadState() || {
    current: newBlankList("Today"),
    dishCatalog: [],
    currentMenu: [],
    masterGroceries: [],
    upcDB: {},
    deviceName: "",
    // categoryPrefs holds user additions + order.
    categoryPrefs: {
      custom: {},   // { [id]: { label } }
      order: []     // array of category IDs (walking order)
    }
  };

  // Ensure deviceName exists
  if(typeof state.deviceName !== "string"){
    state.deviceName = "";
  }
  if(!state.deviceName.trim()){
    const plat = (navigator.platform || "").replace(/\s+/g," ").trim();
    state.deviceName = plat ? plat : "My Device";
    saveState(state);
  }

  // PHASE 2: per-menu "Add Ingredients" checkboxes (default UNCHECKED)
  if(!state.menuAddFlags || typeof state.menuAddFlags !== "object"){
    state.menuAddFlags = {};
    saveState(state);
  }

  // Ensure categoryPrefs shape
  if(!state.categoryPrefs || typeof state.categoryPrefs !== "object"){
    state.categoryPrefs = { custom:{}, order:[] };
  }
  if(!state.categoryPrefs.custom || typeof state.categoryPrefs.custom !== "object"){
    state.categoryPrefs.custom = {};
  }
  if(!Array.isArray(state.categoryPrefs.order)){
    state.categoryPrefs.order = [];
  }

  // =========================
  // CATEGORY ENGINE (defaults + user additions + order)
  // =========================
  function getAllCats(){
    // merge built-in + custom
    const built = DEFAULT_CATS.map(c => ({ id:c.id, label:c.label, builtIn:true }));
    const custom = Object.keys(state.categoryPrefs.custom || {}).map(id => ({
      id,
      label: state.categoryPrefs.custom[id]?.label || id,
      builtIn:false
    }));

    // dedupe by id, prefer built-in label if conflict
    const map = new Map();
    built.forEach(c => map.set(c.id, c));
    custom.forEach(c => {
      if(!map.has(c.id)) map.set(c.id, c);
    });

    // ensure misc exists
    if(!map.has("misc")) map.set("misc", { id:"misc", label:"Misc", builtIn:true });

    const all = Array.from(map.values());

    // order: use saved order then append missing
    const order = Array.isArray(state.categoryPrefs.order) ? [...state.categoryPrefs.order] : [];
    const inOrder = new Set(order);
    all.forEach(c => { if(!inOrder.has(c.id)) order.push(c.id); });

    // finally build ordered list
    const byId = new Map(all.map(c => [c.id, c]));
    const ordered = order.map(id => byId.get(id)).filter(Boolean);

    return ordered;
  }

  function catLabelById(id){
    id = String(id || "misc");
    const all = getAllCats();
    const found = all.find(c => c.id === id);
    return found ? found.label : "Misc";
  }

  function findCatIdByLabel(label){
    const want = normName(label).toLowerCase();
    if(!want) return "misc";
    const all = getAllCats();
    const exact = all.find(c => normName(c.label).toLowerCase() === want);
    return exact ? exact.id : null;
  }

  function ensureCatForLabel(label){
    const existing = findCatIdByLabel(label);
    if(existing) return existing;

    // create custom
    const base = slugify(label);
    let id = base;
    let tries = 0;
    while (DEFAULT_CATS.some(c => c.id === id) || state.categoryPrefs.custom[id]) {
      tries++;
      id = `${base}-${tries}`;
      if(tries > 50) { id = `${base}-${generateId().slice(0,6)}`; break; }
    }
    state.categoryPrefs.custom[id] = { label: normName(label) || "New Category" };

    // append to end of order
    if(!state.categoryPrefs.order.includes(id)){
      state.categoryPrefs.order.push(id);
    }

    saveState(state);
    return id;
  }

  function catIndexById(catId){
    const ordered = getAllCats();
    const i = ordered.findIndex(c => c.id === String(catId || "misc"));
    return i === -1 ? ordered.length + 999 : i;
  }

  function sortByCatThenName(a, b){
    const ai = catIndexById(a.catId);
    const bi = catIndexById(b.catId);
    if(ai !== bi) return ai - bi;
    const an = normName(a.name).toLowerCase();
    const bn = normName(b.name).toLowerCase();
    if(an < bn) return -1;
    if(an > bn) return 1;
    return 0;
  }

  function sameItem(a, b){
    const an = normName(a.name).toLowerCase();
    const bn = normName(b.name).toLowerCase();
    const ac = String(a.catId || "misc");
    const bc = String(b.catId || "misc");
    return an === bn && ac === bc;
  }
  function hasItem(arr, cand){ return arr.some(x => sameItem(x, cand)); }

  // Dish helpers
  function sameDishName(a, b){
    return normName(a).toLowerCase() === normName(b).toLowerCase();
  }
  function hasDish(arr, name){
    return (arr||[]).some(x => sameDishName(x, name));
  }

  // Safe key encoding for dataset attributes
  function dishKey(name){ return encodeURIComponent(String(name ?? "")); }
  function undishKey(k){
    try { return decodeURIComponent(String(k ?? "")); } catch { return String(k ?? ""); }
  }

  // =========================
  // MIGRATION: old "cat" strings -> catId
  // - Also upgrade masterGroceries entries to include catId
  // - Any unknown cats become user custom categories
  // =========================
  (function migrateCategories(){
    let changed = false;

    function migrateItem(obj){
      if(!obj || typeof obj !== "object") return;
      if(obj.catId) return;
      const oldCat = normName(obj.cat || "");
      const cid = oldCat ? ensureCatForLabel(oldCat) : "misc";
      obj.catId = cid;
      if("cat" in obj) delete obj.cat; // keep clean
      changed = true;
    }

    // current items
    (state.current?.items || []).forEach(migrateItem);

    // master list
    (state.masterGroceries || []).forEach(m => {
      if(!m || typeof m !== "object") return;
      if(m.catId) return;
      const oldCat = normName(m.cat || "");
      const cid = oldCat ? ensureCatForLabel(oldCat) : "misc";
      m.catId = cid;
      if("cat" in m) delete m.cat;
      changed = true;
    });

    // UPC DB
    if(state.upcDB && typeof state.upcDB === "object"){
      Object.keys(state.upcDB).forEach(code => {
        const entry = state.upcDB[code];
        if(!entry || typeof entry !== "object") return;
        if(entry.catId) return;
        const oldCat = normName(entry.cat || "");
        const cid = oldCat ? ensureCatForLabel(oldCat) : "misc";
        entry.catId = cid;
        if("cat" in entry) delete entry.cat;
        changed = true;
      });
    }

    // Dish ingredient cats
    (state.dishCatalog || []).forEach(d => {
      const ings = Array.isArray(d?.ingredients) ? d.ingredients : [];
      ings.forEach(i => {
        if(!i || typeof i !== "object") return;
        if(i.catId) return;
        const oldCat = normName(i.cat || "");
        const cid = oldCat ? ensureCatForLabel(oldCat) : "misc";
        i.catId = cid;
        if("cat" in i) delete i.cat;
        changed = true;
      });
    });

    if(changed){
      console.log("[MIGRATE] Categories upgraded to catId + local categoryPrefs");
      saveState(state);
    }
  })();

  // =========================
  // PHASE 1: Dish object migration (SAFE / INVISIBLE)
  // =========================
  (function migrateDishData(){
    let changed = false;

    // Ensure dishCatalog entries are objects with ingredients[]
    state.dishCatalog = (state.dishCatalog || []).map(d => {
      if (typeof d === "string") {
        changed = true;
        return { name: d, ingredients: [] };
      }
      if (!d || typeof d !== "object") {
        changed = true;
        return { name: String(d ?? ""), ingredients: [] };
      }
      if (!("name" in d)) {
        changed = true;
        d.name = String(d.name ?? "");
      }
      if (!Array.isArray(d.ingredients)) {
        changed = true;
        d.ingredients = [];
      }
      return d;
    }).filter(d => normName(d.name));

    // Ensure currentMenu is array of dish names (strings)
    state.currentMenu = (state.currentMenu || [])
      .map(d => typeof d === "string" ? d : d?.name)
      .filter(Boolean);

    if (changed) {
      console.log("[PHASE 1] Dish data migrated");
      saveState(state);
    }
  })();

  let lastAddedId = null;
  let renderTimeout = null;

  // =========================
  // Add/Edit Item Modal
  // =========================
  const miniBg = document.getElementById("miniBg");
  const miniTitle = document.getElementById("miniTitle");
  const miniName = document.getElementById("miniName");
  const miniCat = document.getElementById("miniCat");
  let miniResolve = null;

  function buildCatOptions(selectedId){
    const cats = getAllCats();
    miniCat.innerHTML = cats.map(c => {
      const sel = String(selectedId||"misc") === c.id ? "selected" : "";
      return `<option value="${escapeHtml(c.id)}" ${sel}>${escapeHtml(c.label)}</option>`;
    }).join("");
  }

  function openItemModal(title, defaults = {name:"", catId:"misc"}){
    miniTitle.textContent = title;
    miniName.value = defaults.name || "";
    buildCatOptions(defaults.catId || "misc");
    miniBg.style.display = "flex";
    setTimeout(()=> miniName.focus(), 80);
    return new Promise(resolve => { miniResolve = resolve; });
  }

  function closeItemModal(result){
    miniBg.style.display = "none";
    const r = miniResolve;
    miniResolve = null;
    if(r) r(result);
  }

  document.getElementById("miniClose").onclick = () => closeItemModal(null);
  document.getElementById("miniCancel").onclick = () => closeItemModal(null);
  document.getElementById("miniOk").onclick = () => {
    const name = normName(miniName.value);
    const catId = String(miniCat.value || "misc");
    if(!name){
      showToast("Please enter a name", 1600);
      miniName.focus();
      return;
    }
    closeItemModal({ name, catId });
  };
  miniBg.onclick = e => { if(e.target === miniBg) closeItemModal(null); };

  // =========================
  // Category Manager Modal (Add/Rename/Delete/Reorder)
  // =========================
  const catBg = document.getElementById("catBg");
  const catMgrList = document.getElementById("catMgrList");
  const catNewName = document.getElementById("catNewName");
  const catAddBtn = document.getElementById("catAddBtn");

  let catMgrSnapshot = null; // for cancel restore

  function openCatManager(){
    // snapshot so cancel can revert
    catMgrSnapshot = JSON.stringify(state.categoryPrefs || { custom:{}, order:[] });

    catNewName.value = "";
    renderCatManagerList();
    catBg.style.display = "flex";
    setTimeout(()=> catNewName.focus(), 80);
  }

  function closeCatManager(save){
    if(!save){
      // restore snapshot
      try{
        const snap = JSON.parse(catMgrSnapshot || "{}");
        state.categoryPrefs = snap;
        if(!state.categoryPrefs.custom) state.categoryPrefs.custom = {};
        if(!Array.isArray(state.categoryPrefs.order)) state.categoryPrefs.order = [];
        saveState(state);
      }catch{}
    } else {
      saveState(state);
    }
    catMgrSnapshot = null;
    catBg.style.display = "none";
    debouncedRender();
  }

  function renderCatManagerList(){
    const cats = getAllCats();

    catMgrList.innerHTML = cats.map(c => `
      <div class="catMgrRow" draggable="true" data-id="${escapeHtml(c.id)}">
        <div class="dragHandle" title="Drag to reorder">‚â°</div>
        <input class="catNameInput" type="text" value="${escapeHtml(c.label)}" />
        <span class="catBadge ${c.builtIn ? "builtIn":"custom"}">${c.builtIn ? "DEFAULT":"CUSTOM"}</span>
        <button class="delBtn" title="Delete" ${c.id==="misc" ? "disabled":""}>üóëÔ∏è</button>
      </div>
    `).join("");

    // bind rename + delete
    catMgrList.querySelectorAll(".catMgrRow").forEach(row => {
      const id = row.dataset.id;
      const input = row.querySelector(".catNameInput");
      const del = row.querySelector(".delBtn");

      // rename
      input.addEventListener("change", () => {
        const newLabel = normName(input.value);
        if(!newLabel){
          input.value = catLabelById(id);
          showToast("Name cannot be blank.", 1600);
          return;
        }

        // if built-in, store override in custom map? Keep simple:
        // We'll allow renaming built-in by writing to custom override table
        // BUT we must not lose built-in id.
        if(DEFAULT_CATS.some(x => x.id === id)){
          // store override in custom with same id
          state.categoryPrefs.custom[id] = { label: newLabel };
        } else {
          // regular custom
          if(!state.categoryPrefs.custom[id]) state.categoryPrefs.custom[id] = { label: newLabel };
          else state.categoryPrefs.custom[id].label = newLabel;
        }
        saveState(state);
        // do NOT re-render here (avoids cursor jump)
      });

      // delete
      del?.addEventListener("click", () => {
        if(id === "misc") return;

        // built-ins: we don't allow deleting defaults (only rename)
        const isBuilt = DEFAULT_CATS.some(x => x.id === id);
        if(isBuilt){
          showToast("Default categories can't be deleted (rename is OK).", 2200);
          return;
        }

        const ok = confirm(`Delete category "${catLabelById(id)}"?\n\nAll items in that category will move to Misc.`);
        if(!ok) return;

        // remove from custom + order
        if(state.categoryPrefs.custom && state.categoryPrefs.custom[id]){
          delete state.categoryPrefs.custom[id];
        }
        state.categoryPrefs.order = (state.categoryPrefs.order || []).filter(x => x !== id);

        // reassign items
        (state.current?.items || []).forEach(it => { if(it.catId === id) it.catId = "misc"; });
        (state.masterGroceries || []).forEach(m => { if(m.catId === id) m.catId = "misc"; });
        if(state.upcDB && typeof state.upcDB === "object"){
          Object.keys(state.upcDB).forEach(code => {
            if(state.upcDB[code]?.catId === id) state.upcDB[code].catId = "misc";
          });
        }
        (state.dishCatalog || []).forEach(d => {
          (d.ingredients || []).forEach(i => { if(i.catId === id) i.catId = "misc"; });
        });

        saveState(state);
        renderCatManagerList();
        showToast("Category deleted (moved items to Misc).", 1800);
      });
    });

    // drag reorder
    bindCatDragAndDrop();
  }

  function bindCatDragAndDrop(){
    const rows = Array.from(catMgrList.querySelectorAll(".catMgrRow"));
    let dragEl = null;

    rows.forEach(r => {
      r.addEventListener("dragstart", (e) => {
        dragEl = r;
        r.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", r.dataset.id || "");
      });

      r.addEventListener("dragend", () => {
        r.classList.remove("dragging");
        dragEl = null;
      });

      r.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        const target = r;
        if(!dragEl || target === dragEl) return;

        const rect = target.getBoundingClientRect();
        const before = (e.clientY - rect.top) < rect.height / 2;

        if(before){
          target.parentNode.insertBefore(dragEl, target);
        } else {
          target.parentNode.insertBefore(dragEl, target.nextSibling);
        }
      });

      r.addEventListener("drop", (e) => {
        e.preventDefault();
        // update order based on DOM
        const orderedIds = Array.from(catMgrList.querySelectorAll(".catMgrRow"))
          .map(x => x.dataset.id)
          .filter(Boolean);

        state.categoryPrefs.order = orderedIds;
        saveState(state);
      });
    });
  }

  catAddBtn.onclick = () => {
    const label = normName(catNewName.value);
    if(!label){
      showToast("Enter a category name.", 1600);
      catNewName.focus();
      return;
    }
    ensureCatForLabel(label);
    catNewName.value = "";
    renderCatManagerList();
    showToast("Category added.", 1400);
  };

  document.getElementById("catCloseX").onclick = () => closeCatManager(false);
  document.getElementById("catCancel").onclick = () => closeCatManager(false);
  document.getElementById("catSave").onclick = () => closeCatManager(true);
  catBg.onclick = (e) => { if(e.target === catBg) closeCatManager(false); };

  // =========================
  // PHASE 2: Dish Ingredients Modal
  // =========================
  const dishBg = document.getElementById("dishBg");
  const dishTitle = document.getElementById("dishTitle");
  const dishIngList = document.getElementById("dishIngList");

  let dishEditingName = null;
  let dishEditingSnapshot = null;

  function buildCatSelect(selectedId){
    const cats = getAllCats();
    return `
      <select class="ingCat">
        ${cats.map(c => `<option value="${escapeHtml(c.id)}" ${String(selectedId||"misc")===c.id?"selected":""}>${escapeHtml(c.label)}</option>`).join("")}
      </select>
    `;
  }

  function addIngRow({name="", catId="misc"} = {}){
    const row = document.createElement("div");
    row.className = "ingRow";
    row.innerHTML = `
      <input class="ingName" type="text" placeholder="Ingredient name" value="${escapeHtml(name)}">
      ${buildCatSelect(catId || "misc")}
      <button class="delBtn" type="button" title="Remove">üóëÔ∏è</button>
    `;
    row.querySelector(".delBtn").onclick = () => row.remove();
    dishIngList.appendChild(row);
  }

  function getDishObjByName(name){
    const n = normName(name).toLowerCase();
    return (state.dishCatalog || []).find(d => normName(d.name).toLowerCase() === n) || null;
  }

  function openDishIngredientsModal(dishName){
    const dish = getDishObjByName(dishName);
    if(!dish){
      showToast("Dish not found in catalog.", 1600);
      return;
    }

    dishEditingName = dish.name;
    dishEditingSnapshot = JSON.stringify(dish.ingredients || []);

    dishTitle.textContent = `Ingredients: ${dish.name}`;
    dishIngList.innerHTML = "";

    const ings = Array.isArray(dish.ingredients) ? dish.ingredients : [];
    if(ings.length){
      ings.forEach(x => addIngRow({ name: x.name, catId: x.catId || "misc" }));
    }

    dishBg.style.display = "flex";
  }

  function closeDishModal(save){
    if(!dishEditingName){
      dishBg.style.display = "none";
      return;
    }

    const dish = getDishObjByName(dishEditingName);
    if(!dish){
      dishBg.style.display = "none";
      dishEditingName = null;
      return;
    }

    if(!save){
      // restore snapshot
      try { dish.ingredients = JSON.parse(dishEditingSnapshot || "[]"); }
      catch { dish.ingredients = dish.ingredients || []; }
      dishBg.style.display = "none";
      dishEditingName = null;
      dishEditingSnapshot = null;
      return;
    }

    // collect rows
    const out = [];
    dishIngList.querySelectorAll(".ingRow").forEach(r => {
      const n = normName(r.querySelector(".ingName")?.value || "");
      const cId = String(r.querySelector(".ingCat")?.value || "misc");
      if(!n) return;
      out.push({ name: n, catId: cId });
    });

    // de-dupe within dish by name+catId
    const seen = new Set();
    dish.ingredients = out.filter(x => {
      const k = normName(x.name).toLowerCase() + "|" + String(x.catId||"misc");
      if(seen.has(k)) return false;
      seen.add(k);
      return true;
    });

    saveState(state);
    debouncedRender();

    dishBg.style.display = "none";
    dishEditingName = null;
    dishEditingSnapshot = null;

    showToast("Ingredients saved.", 1400);
  }

  document.getElementById("dishAddIng").onclick = () => addIngRow({name:"", catId:"misc"});
  document.getElementById("dishClose").onclick = () => closeDishModal(false);
  document.getElementById("dishCancel").onclick = () => closeDishModal(false);
  document.getElementById("dishSave").onclick = () => closeDishModal(true);
  dishBg.onclick = (e) => { if(e.target === dishBg) closeDishModal(false); };

  // =========================
  // Groceries: Shopping list
  // =========================
  function addItemToCurrent(name, catId="misc"){
    name = normName(name);
    catId = String(catId || "misc");
    if(!name) return false;

    const item = { id: generateId(), name, catId, done:false, qty:"1", unit:"ea", price:"" };
    if(hasItem(state.current.items, item)) return false;

    state.current.items.push(item);
    lastAddedId = item.id;
    saveState(state);
    debouncedRender();
    return true;
  }

  function deleteItemById(id) {
    const idx = state.current.items.findIndex(x => x.id === id);
    if (idx === -1) return;
    state.current.items.splice(idx, 1);
    if (lastAddedId === id) lastAddedId = null;
    saveState(state);
    debouncedRender();
  }

  function updateItem(id, changes) {
    const item = state.current.items.find(x => x.id === id);
    if (!item) return;
    Object.assign(item, changes);
    saveState(state);
    debouncedRender();
  }

  // =========================
  // Groceries: Master list
  // =========================
  function addToMaster(name, catId="misc"){
    name = normName(name);
    catId = String(catId || "misc");
    if(!name) return false;

    const entry = { name, catId };
    if(hasItem(state.masterGroceries, entry)) return false;

    state.masterGroceries.push(entry);
    saveState(state);
    debouncedRender();
    return true;
  }

  function removeFromMaster(name, catId){
    const n = normName(name).toLowerCase();
    const c = String(catId || "misc");
    state.masterGroceries = state.masterGroceries.filter(x =>
      !(normName(x.name).toLowerCase()===n && String(x.catId||"misc")===c)
    );
    saveState(state);
    debouncedRender();
  }

  // =========================
  // Dishes
  // =========================
  function hasDishObjByName(name){
    const n = normName(name).toLowerCase();
    return (state.dishCatalog || []).some(d => normName(d.name).toLowerCase() === n);
  }

  function addDishToCatalogAndMenu(name){
    name = normName(name);
    if(!name) return {addedCatalog:false, addedMenu:false};

    let addedCatalog = false, addedMenu = false;

    if(!hasDishObjByName(name)){
      state.dishCatalog.push({ name, ingredients: [] });
      addedCatalog = true;
    }

    if(!hasDish(state.currentMenu, name)){
      state.currentMenu.push(name);
      addedMenu = true;
    }

    if(!state.menuAddFlags) state.menuAddFlags = {};
    state.menuAddFlags[name] = false;

    saveState(state);
    debouncedRender();
    return {addedCatalog, addedMenu};
  }

  function removeDishFromMenu(name){
    const n = normName(name).toLowerCase();
    state.currentMenu = (state.currentMenu || []).filter(x => normName(x).toLowerCase() !== n);
    saveState(state);
    debouncedRender();
  }

  function removeDishFromCatalog(name){
    const n = normName(name).toLowerCase();
    state.dishCatalog = (state.dishCatalog || []).filter(d => normName(d.name).toLowerCase() !== n);
    state.currentMenu = (state.currentMenu || []).filter(x => normName(x).toLowerCase() !== n);
    if(state.menuAddFlags) delete state.menuAddFlags[name];
    saveState(state);
    debouncedRender();
  }

  function randomMenu14(){
    const pool = [...(state.dishCatalog || [])];
    for(let i=pool.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    state.currentMenu = pool.slice(0, 14).map(d => d.name);

    state.menuAddFlags = {};
    state.currentMenu.forEach(n => state.menuAddFlags[n] = false);

    saveState(state);
    debouncedRender();
  }

  function debouncedRender() {
    clearTimeout(renderTimeout);
    renderTimeout = setTimeout(render, 60);
  }

  // =========================
  // Add Ingredients from checked menu dishes
  // (also auto-UNcheck after adding)  ‚úÖ v65 behavior
  // =========================
  function addIngredientsForCheckedMenu(){
    let dishesChecked = 0;
    let ingAdded = 0;
    let ingAlready = 0;
    let ingMissing = 0;

    const menuRows = Array.from(document.querySelectorAll("#menuCard .dishRow"));

    const checkedMap = {};
    menuRows.forEach(row => {
      const key = row.dataset.key || "";
      const name = undishKey(key);
      const chk = row.querySelector(".ingCheck");
      checkedMap[name] = !!chk?.checked;
    });

    state.currentMenu.forEach(dishName => {
      const isChecked = Object.prototype.hasOwnProperty.call(checkedMap, dishName)
        ? checkedMap[dishName]
        : !!state.menuAddFlags?.[dishName];

      if(!isChecked) return;

      dishesChecked++;

      const dish = getDishObjByName(dishName);
      const ings = dish?.ingredients || [];
      if(!ings.length){
        ingMissing++;
        return;
      }

      ings.forEach(ing => {
        const n = normName(ing.name);
        const cId = String(ing.catId || "misc");
        if(!n) return;

        addToMaster(n, cId);

        const ok = addItemToCurrent(n, cId);
        if(ok){
          const it = state.current.items.find(x =>
            normName(x.name).toLowerCase()===n.toLowerCase()
            && String(x.catId||"misc")===cId
          );
          if(it){
            it.qty = "1";
            it.unit = "ea";
          }
          ingAdded++;
        } else {
          ingAlready++;
        }
      });
    });

    menuRows.forEach(row => {
      const chk = row.querySelector(".ingCheck");
      if(chk && chk.checked){
        chk.checked = false;
      }
      const name = undishKey(row.dataset.key || "");
      if(state.menuAddFlags && name) state.menuAddFlags[name] = false;
    });

    saveState(state);
    debouncedRender();

    if(dishesChecked === 0){
      showToast("No dishes checked.", 1600);
      return;
    }

    const msg =
      `Checked dishes: ${dishesChecked} ‚Ä¢ Added: ${ingAdded}` +
      (ingAlready ? ` ‚Ä¢ Already: ${ingAlready}` : "") +
      (ingMissing ? ` ‚Ä¢ No ingredients: ${ingMissing}` : "");

    showToast(msg, 2600);
  }

  // =========================
  // Render
  // =========================
  function renderGroceries() {
    document.getElementById("listName").textContent = state.current.name;
    document.getElementById("total").textContent = money(computeTotal());

    const sortedCurrent = [...state.current.items].sort((a,b) => sortByCatThenName(a,b));
    const card = document.getElementById("listCard");

    if (sortedCurrent.length === 0) {
      card.innerHTML = `<div style="padding:16px; text-align:center;">
        <div class="muted">No items yet.</div>
        <div class="muted">Tap <b>SCAN QR</b>, <b>SCAN UPC</b>, or <b>Add Item</b>.</div>
      </div>`;
    } else {
      card.innerHTML = sortedCurrent.map(it => `
        <div class="item ${it.done ? "done":""}" data-id="${it.id}">
          <input class="check" type="checkbox" ${it.done ? "checked":""}>
          <div class="name">${escapeHtml(it.name)}</div>
          <span class="catPill">${escapeHtml(catLabelById(it.catId))}</span>
          <input class="qty" type="number" step="0.5" min="0" value="${escapeHtml(it.qty)}">
          <select class="unit">
            ${UNITS.map(u => `<option ${u===it.unit?"selected":""}>${escapeHtml(u)}</option>`).join("")}
          </select>
          <input class="price" type="number" step="0.01" min="0" placeholder="$" value="${escapeHtml(it.price)}">
          <button class="delBtn" title="Delete">üóëÔ∏è</button>
        </div>
      `).join("");

      card.querySelectorAll(".item").forEach(row => {
        const id = row.dataset.id;
        const item = state.current.items.find(x => x.id === id);
        if (!item) return;

        row.querySelector(".check").onchange = e => updateItem(id, { done: e.target.checked });

        row.querySelector(".qty").onchange = e => {
          let v = parseFloat(e.target.value) || 0;
          v = Math.max(0, Math.min(999, v));
          updateItem(id, { qty: String(v) });
        };

        row.querySelector(".unit").onchange = e => updateItem(id, { unit: e.target.value });

        row.querySelector(".price").onchange = e => {
          let v = parseFloat(e.target.value);
          updateItem(id, { price: isNaN(v) ? "" : String(Math.max(0, v)) });
        };

        row.querySelector(".delBtn").onclick = () => deleteItemById(id);

        row.querySelector(".name").onclick = async () => {
          const res = await openItemModal("Edit Item", { name: item.name, catId: item.catId || "misc" });
          if(!res) return;

          const cand = { name: res.name, catId: res.catId };
          const others = state.current.items.filter(x => x.id !== id);
          if(hasItem(others, cand)){
            showToast("That item already exists in the Shopping List.", 1900);
            return;
          }
          updateItem(id, { name: res.name, catId: res.catId });
        };
      });
    }

    // Master list
    const sortedMaster = [...state.masterGroceries].sort((a,b)=>sortByCatThenName(a,b));
    document.getElementById("masterCount").textContent = sortedMaster.length;

    const masterCard = document.getElementById("masterCard");
    if(sortedMaster.length === 0){
      masterCard.innerHTML = `<div style="padding:14px; text-align:center;">
        <div class="muted">Master list is empty.</div>
        <div class="muted">Scan QR/UPC or add items to build your master list.</div>
      </div>`;
    } else {
      masterCard.innerHTML = sortedMaster.map((m, idx) => `
        <div class="masterRow" data-idx="${idx}">
          <input class="mCheck" type="checkbox">
          <div class="mName">${escapeHtml(m.name)}</div>
          <span class="catPill">${escapeHtml(catLabelById(m.catId))}</span>
          <button class="delBtn" title="Delete from Master">üóëÔ∏è</button>
        </div>
      `).join("");

      const rows = Array.from(masterCard.querySelectorAll(".masterRow"));
      rows.forEach(row => {
        const idx = parseInt(row.dataset.idx, 10);
        const m = sortedMaster[idx];
        if(!m) return;

        row.querySelector(".mName").onclick = async () => {
          const res = await openItemModal("Edit Master Item", { name: m.name, catId: m.catId || "misc" });
          if(!res) return;
          removeFromMaster(m.name, m.catId);
          addToMaster(res.name, res.catId);
          showToast("Master item updated.", 1500);
        };

        row.querySelector(".delBtn").onclick = () => {
          const ok = confirm(`Delete from Master?\n\n${m.name} (${catLabelById(m.catId)})`);
          if(!ok) return;
          removeFromMaster(m.name, m.catId);
        };
      });
    }
  }

  function dishRowHtml(name, where){
    const dish = getDishObjByName(name);
    const hasIng = !!(dish && Array.isArray(dish.ingredients) && dish.ingredients.length);

    const menuControls = (where === "menu") ? `
      <label style="display:flex;align-items:center;gap:8px; font-weight:900;">
        <input class="ingCheck" type="checkbox" ${state.menuAddFlags?.[name] ? "checked":""}>
        <span title="${hasIng ? "Has ingredients" : "No ingredients yet"}" style="font-size:18px; opacity:${hasIng ? "1":"0.35"};">üßÇ</span>
      </label>
    ` : `
      <span title="${hasIng ? "Has ingredients" : "No ingredients yet"}" style="font-size:18px; opacity:${hasIng ? "1":"0.35"};">üßÇ</span>
    `;

    return `
      <div class="dishRow" data-key="${dishKey(name)}" data-where="${where}">
        <div style="display:flex; align-items:center; gap:12px;">
          ${menuControls}
          <div class="dishName">${escapeHtml(name)}</div>
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          ${where==="menu" ? `<span class="pill ok">MENU</span>` : `<span class="pill">CATALOG</span>`}
          <button class="delBtn" title="Delete">üóëÔ∏è</button>
        </div>
      </div>
    `;
  }

  function renderDishes(){
    document.getElementById("menuCount").textContent = (state.currentMenu || []).length;
    document.getElementById("catalogCount").textContent = (state.dishCatalog || []).length;

    const menuCard = document.getElementById("menuCard");
    if(!state.currentMenu || state.currentMenu.length === 0){
      menuCard.innerHTML = `<div style="padding:16px; text-align:center;">
        <div class="muted">Menu is empty.</div>
        <div class="muted">Scan a dish QR or tap <b>Random Menu (14)</b>.</div>
      </div>`;
    } else {
      menuCard.innerHTML = state.currentMenu.map(d => dishRowHtml(d, "menu")).join("");
    }

    const catalogCard = document.getElementById("catalogCard");
    if(!state.dishCatalog || state.dishCatalog.length === 0){
      catalogCard.innerHTML = `<div style="padding:16px; text-align:center;">
        <div class="muted">Catalog is empty.</div>
        <div class="muted">Scan dish QR codes to build it.</div>
      </div>`;
    } else {
      catalogCard.innerHTML = state.dishCatalog.map(d => dishRowHtml(d.name, "catalog")).join("");
    }

    function bindDishRows(container){
      container.querySelectorAll(".dishRow").forEach(row=>{
        const name = undishKey(row.dataset.key || "");
        const where = row.dataset.where;

        const chk = row.querySelector(".ingCheck");
        if(chk){
          chk.checked = !!state.menuAddFlags?.[name];

          chk.onchange = (e) => {
            e.stopPropagation();
            if(!state.menuAddFlags) state.menuAddFlags = {};
            state.menuAddFlags[name] = !!chk.checked;
            saveState(state);
          };

          chk.onclick = (e) => e.stopPropagation();
        }

        row.querySelector(".dishName").onclick = () => {
          if(where === "catalog"){
            addDishToCatalogAndMenu(name);
            return;
          }

          const allowed = !!row.querySelector(".ingCheck")?.checked;

          if(allowed){
            openDishIngredientsModal(name);
            return;
          }

          const newName = prompt("Rename dish (updates Catalog + Menu):", name);
          if(!newName) return;
          const nn = normName(newName);
          if(!nn) return;

          removeDishFromCatalog(name);
          addDishToCatalogAndMenu(nn);

          if(state.menuAddFlags){
            delete state.menuAddFlags[name];
            state.menuAddFlags[nn] = false;
            saveState(state);
          }
        };

        row.querySelector(".delBtn").onclick = () => {
          if(where === "menu"){
            const choice = prompt(`Delete "${name}"?\nType:\nM = remove from Menu only\nC = remove from Catalog (also removes from Menu)\n(Anything else cancels)`, "M");
            if(!choice) return;
            const ch = choice.trim().toUpperCase();
            if(ch === "M") removeDishFromMenu(name);
            else if(ch === "C") removeDishFromCatalog(name);
          } else {
            const choice = prompt(`Delete "${name}"?\nType:\nC = remove from Catalog (also removes from Menu)\nM = remove from Menu only\n(Anything else cancels)`, "C");
            if(!choice) return;
            const ch = choice.trim().toUpperCase();
            if(ch === "C") removeDishFromCatalog(name);
            else if(ch === "M") removeDishFromMenu(name);
          }
        };
      });
    }

    bindDishRows(menuCard);
    bindDishRows(catalogCard);
  }

  function render(){
    renderGroceries();
    renderDishes();
    renderTools();
  }

  // =========================
  // Tabs / Screens
  // =========================
  const tabGroceries = document.getElementById("tabGroceries");
  const tabDishes = document.getElementById("tabDishes");
  const screenGroceries = document.getElementById("screenGroceries");
  const screenDishes = document.getElementById("screenDishes");
  const screenTools = document.getElementById("screenTools");
  const btnMore = document.getElementById("btnMore");

  function showTab(which){
    const isG = which === "groceries";
    const isD = which === "dishes";
    const isT = which === "tools";

    screenGroceries.style.display = isG ? "" : "none";
    screenDishes.style.display   = isD ? "" : "none";
    screenTools.style.display    = isT ? "" : "none";

    tabGroceries.classList.toggle("active", isG);
    tabDishes.classList.toggle("active", isD);

    document.getElementById("btnClearDone").style.display = isG ? "" : "none";
    btnMore.style.display = isG ? "" : "none";
  }

  tabGroceries.onclick = () => showTab("groceries");
  tabDishes.onclick = () => showTab("dishes");

  btnMore.onclick = () => showTab("tools");
  document.getElementById("btnToolsBack").onclick = () => showTab("groceries");

  // =========================
  // Grocery actions
  // =========================
  document.getElementById("btnNew").onclick = () => {
    const name = prompt("List name?", state.current.name);
    if (!name?.trim()) return;
    state.current = newBlankList(name.trim());
    lastAddedId = null;
    saveState(state);
    render();
  };

  document.getElementById("btnAdd").onclick = async () => {
    const res = await openItemModal("Add Item", { name:"", catId:"misc" });
    if(!res) return;

    addToMaster(res.name, res.catId);

    const also = confirm(`Add to Current Shopping List too?\n\n${res.name} (${catLabelById(res.catId)})`);
    if(also){
      const ok = addItemToCurrent(res.name, res.catId);
      showToast(ok ? `Added: ${res.name}` : `Already in Shopping List: ${res.name}`, 1800);
    } else {
      showToast(`Added to Master only: ${res.name}`, 1800);
    }
  };

  document.getElementById("btnUndo").onclick = () => {
    if (lastAddedId) deleteItemById(lastAddedId);
  };

  document.getElementById("btnClearDone").onclick = () => {
    const before = state.current.items.length;
    state.current.items = state.current.items.filter(x => !x.done);
    if (state.current.items.length !== before) {
      saveState(state);
      render();
    }
  };

  document.getElementById("btnMasterAddSelected").onclick = () => {
    const masterCard = document.getElementById("masterCard");
    const rows = Array.from(masterCard.querySelectorAll(".masterRow"));
    if(rows.length === 0) return;

    let added = 0;
    let already = 0;

    rows.forEach(r => {
      const cb = r.querySelector(".mCheck");
      if(!cb || !cb.checked) return;

      const name = r.querySelector(".mName")?.textContent || "";
      // read cat label pill -> map to catId (safe fallback)
      const catLabel = r.querySelector(".catPill")?.textContent || "Misc";
      const catId = findCatIdByLabel(catLabel) || ensureCatForLabel(catLabel);

      const ok = addItemToCurrent(name, catId);
      if(ok) added++; else already++;

      cb.checked = false;
    });

    if(added === 0 && already === 0){
      showToast("No items checked.", 1600);
    } else {
      const msg = `Added ${added} item(s)` + (already ? ` (${already} already in list)` : "");
      showToast(msg, 2200);
    }
  };

  document.getElementById("btnMasterClearChecks").onclick = () => {
    document.querySelectorAll("#masterCard .mCheck").forEach(cb => cb.checked = false);
    showToast("Master checks cleared.", 1400);
  };

  document.getElementById("btnMasterClear").onclick = () => {
    if(!confirm("Clear the entire Master Grocery List?")) return;
    state.masterGroceries = [];
    saveState(state);
    render();
  };

  // ===== Open Category Manager =====
  document.getElementById("btnCats").onclick = openCatManager;
  document.getElementById("btnCatsTools").onclick = openCatManager;

  // =========================
  // Dish actions
  // =========================
  document.getElementById("btnRandom14").onclick = () => {
    if(!state.dishCatalog || state.dishCatalog.length === 0){
      alert("Catalog is empty. Scan some dish QR codes first.");
      return;
    }
    randomMenu14();
  };

  document.getElementById("btnAddCheckedIng").onclick = () => {
    addIngredientsForCheckedMenu();
  };

  document.getElementById("btnClearMenu").onclick = () => {
    if(!confirm("Clear the current menu?")) return;
    state.currentMenu = [];
    state.menuAddFlags = {};
    saveState(state);
    render();
  };

  document.getElementById("btnClearCatalog").onclick = () => {
    if(!confirm("Clear the entire Dish Catalog AND Menu?")) return;
    state.dishCatalog = [];
    state.currentMenu = [];
    state.menuAddFlags = {};
    saveState(state);
    render();
  };

  document.getElementById("btnAddDish").onclick = () => {
    const name = prompt("Enter dish name:");
    if (!name) return;
    const normalized = normName(name);
    if (!normalized) {
      showToast("Please enter a valid dish name", 1800);
      return;
    }
    const result = addDishToCatalogAndMenu(normalized);
    showToast((result.addedCatalog || result.addedMenu) ? `Added dish: ${normalized}` : `Already exists: ${normalized}`, 1800);
  };

  // =========================
  // Scanner logic (QR + UPC modes)
  // =========================
  const modalBg = document.getElementById("modalBg");
  const scanMsgEl = document.getElementById("scanMsg");
  const scanTitleEl = document.getElementById("scanTitle");
  const scanHintEl = document.getElementById("scanHint");
  let qr = null;

  let scanMode = "qr";
  let pending = null;
  let targetLocked = false;
  let audioCtx = null;

  function beep() {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine"; osc.frequency.value = 880;
      gain.gain.value = 0.06;
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start();
      setTimeout(() => osc.stop(), 90);
    } catch {}
  }

  function setScanMsg(text, cls = "") {
    scanMsgEl.textContent = text;
    scanMsgEl.className = "scanMsg" + (cls ? ` ${cls}` : "");
  }

  function resetTarget() {
    pending = null;
    targetLocked = false;
    document.getElementById("btnCapture").disabled = true;
    setScanMsg("Point camera at code ‚Äì hold steady‚Ä¶");
  }

  function parseQR(decodedText){
    let raw = String(decodedText ?? "");
    raw = raw.replace(/\uFEFF/g, "");
    raw = raw.replace(/\r\n/g, "\n").trim();
    raw = raw.slice(0, 2000);

    if(!raw) return { kind:"unknown", raw:"" };

    const maybeDecode = (s) => {
      s = String(s ?? "");
      if (/%[0-9A-Fa-f]{2}/.test(s)) {
        try { return decodeURIComponent(s); } catch {}
      }
      return s;
    };

    const lower = raw.toLowerCase();

    try {
      if (/^[a-z]+:\/\//i.test(raw)) {
        const url = new URL(raw);

        const dish = url.searchParams.get("dish");
        if (dish) return { kind:"dish", name: maybeDecode(dish).trim().slice(0,120), raw };

        const item = url.searchParams.get("item");
        const cat  = url.searchParams.get("cat");
        if (item) return {
          kind:"item",
          name: maybeDecode(item).trim().slice(0,120),
          cat:  maybeDecode(cat||"").trim().slice(0,80),
          raw
        };

        const text = url.searchParams.get("text");
        if (text) return parseQR(maybeDecode(text).trim());
      }
    } catch {}

    const dishMatch = raw.match(/(?:^|[?&\s])dish=([^&\n]+)/i);
    if (dishMatch) {
      const name = maybeDecode(dishMatch[1]).trim();
      return { kind:"dish", name: name.slice(0,120), raw };
    }

    const itemMatch = raw.match(/(?:^|[?&\s])item=([^&\n]+)/i);
    if (itemMatch) {
      const start = lower.indexOf("item=");
      const qs = raw.slice(start);
      const sp = new URLSearchParams(qs);
      const item = sp.get("item");
      const cat  = sp.get("cat");
      if (item) {
        return {
          kind:"item",
          name: maybeDecode(item).trim().slice(0,120),
          cat:  maybeDecode(cat||"").trim().slice(0,80),
          raw
        };
      }
    }

    return { kind:"unknown", raw: raw.slice(0,140) };
  }

  function parseUPC(decodedText){
    let raw = String(decodedText ?? "").trim();
    raw = raw.replace(/[^\d]/g, "");
    raw = raw.slice(0, 32);
    if(!raw) return { kind:"unknown", raw:"" };
    return { kind:"upc", code: raw, raw };
  }

  async function openScanner(mode){
    scanMode = mode;
    modalBg.style.display = "flex";
    resetTarget();
    document.getElementById("reader").innerHTML = "";

    scanTitleEl.textContent = (mode === "upc") ? "Scan UPC" : "Scan QR";
    scanHintEl.textContent  = (mode === "upc")
      ? "Tip: Center the barcode inside the rectangle and hold steady."
      : "Tip: Fill the square with the QR and hold steady.";

    const formats = (mode === "upc")
      ? [
          Html5QrcodeSupportedFormats.UPC_A,
          Html5QrcodeSupportedFormats.UPC_E,
          Html5QrcodeSupportedFormats.EAN_13,
          Html5QrcodeSupportedFormats.EAN_8,
          Html5QrcodeSupportedFormats.CODE_128
        ]
      : [Html5QrcodeSupportedFormats.QR_CODE];

    qr = new Html5Qrcode("reader", {
      verbose: false,
      formatsToSupport: formats,
      experimentalFeatures: { useBarCodeDetectorIfSupported: true }
    });

    try {
      const cameras = await Html5Qrcode.getCameras();
      if (!cameras?.length) throw new Error("No cameras found");

      const rear = cameras.find(c => /back|rear|environment/i.test(c.label)) || cameras[cameras.length-1];

      const qrboxFunction = () => {
        if(mode === "upc") return { width: 260, height: 110 };
        return { width: 70, height: 70 };
      };

      await qr.start(
        rear.id,
        {
          fps: 12,
          qrbox: qrboxFunction,
          disableFlip: false,
          rememberLastUsedCamera: true,
          aspectRatio: 1.777
        },
        onScanSuccess
      );
    } catch (err) {
      setScanMsg("Camera error ‚Äì check permissions / try again.", "warn");
      console.warn("Scanner start failed:", err);
      setTimeout(closeScanner, 2200);
    }
  }

  async function closeScanner() {
    modalBg.style.display = "none";
    resetTarget();

    if (!qr) return;
    try {
      await qr.stop();
      qr.clear();
    } catch (err) {
      console.warn("Scanner cleanup issue:", err);
    } finally {
      qr = null;
      document.getElementById("reader").innerHTML = "";
    }
  }

  function onScanSuccess(decodedText) {
    if (targetLocked) return;
    targetLocked = true;

    pending = (scanMode === "upc") ? parseUPC(decodedText) : parseQR(decodedText);

    if (navigator.vibrate) navigator.vibrate([30, 20, 30]);
    beep();

    document.getElementById("btnCapture").disabled = false;

    if(pending.kind === "dish"){
      setScanMsg(`Detected DISH: ${pending.name} ‚Üí tap Capture`, "ok");
    } else if(pending.kind === "item"){
      const cat = pending.cat ? ` (${pending.cat})` : "";
      setScanMsg(`Detected ITEM: ${pending.name}${cat} ‚Üí tap Capture`, "ok");
    } else if(pending.kind === "upc"){
      setScanMsg(`Detected UPC: ${pending.code} ‚Üí tap Capture`, "ok");
    } else {
      setScanMsg(`Detected: ${pending.raw} ‚Üí tap Capture`, "warn");
    }
  }

  document.getElementById("btnCapture").onclick = async () => {
    if (!pending) return;

    if(pending.kind === "dish"){
      const r = addDishToCatalogAndMenu(pending.name);
      setScanMsg((r.addedCatalog || r.addedMenu) ? `‚úÖ Dish added: ${pending.name}` : `‚ÑπÔ∏è Dish already exists: ${pending.name}`, "ok");
      showTab("dishes");
    }
    else if(pending.kind === "item"){
      // map cat label -> catId (creates custom if needed)
      const catId = pending.cat ? ensureCatForLabel(pending.cat) : "misc";
      addToMaster(pending.name, catId);
      const ok = addItemToCurrent(pending.name, catId);
      setScanMsg(ok ? `‚úÖ Added item: ${pending.name} (${catLabelById(catId)})` : `‚ÑπÔ∏è Already in list: ${pending.name} (${catLabelById(catId)})`, "ok");
      showTab("groceries");
    }
    else if(pending.kind === "upc"){
      const code = pending.code;

      const known = state.upcDB && state.upcDB[code];
      let entry = known ? { name: known.name, catId: known.catId || "misc" } : null;

      if(!entry){
        const res = await openItemModal("New UPC Item", { name:"", catId:"misc" });
        if(!res){
          setScanMsg("UPC captured, but canceled.", "warn");
          document.getElementById("btnCapture").disabled = true;
          setTimeout(resetTarget, 450);
          return;
        }
        entry = { name: res.name, catId: res.catId || "misc" };

        if(!state.upcDB) state.upcDB = {};
        state.upcDB[code] = { name: entry.name, catId: entry.catId };
        saveState(state);
      }

      addToMaster(entry.name, entry.catId);

      const also = confirm(`UPC: ${code}\n\nItem: ${entry.name} (${catLabelById(entry.catId)})\n\nAdd to Current Shopping List too?`);
      if(also){
        const ok = addItemToCurrent(entry.name, entry.catId);
        setScanMsg(ok ? `‚úÖ Added: ${entry.name} (${catLabelById(entry.catId)})` : `‚ÑπÔ∏è Already in list: ${entry.name} (${catLabelById(entry.catId)})`, "ok");
      } else {
        setScanMsg(`‚úÖ Added to Master only: ${entry.name} (${catLabelById(entry.catId)})`, "ok");
      }

      showTab("groceries");
    }
    else {
      const raw = normName(pending.raw);
      if(raw){
        addToMaster(raw, "misc");
        const also = confirm(`Detected unknown code:\n\n"${raw}"\n\nAdd to Current Shopping List too?`);
        if(also) addItemToCurrent(raw, "misc");
        setScanMsg(`‚úÖ Saved: ${raw}`, "ok");
        showTab("groceries");
      } else {
        setScanMsg("Nothing detected.", "warn");
      }
    }

    document.getElementById("btnCapture").disabled = true;
    setTimeout(resetTarget, 650);
  };

  document.getElementById("btnScan").onclick = () => openScanner("qr");
  document.getElementById("btnScanUPC").onclick = () => openScanner("upc");
  document.getElementById("btnScanDish").onclick = () => openScanner("qr");

  document.getElementById("btnCloseTop").onclick = closeScanner;
  document.getElementById("btnDone").onclick = closeScanner;
  modalBg.onclick = e => { if (e.target === modalBg) closeScanner(); };

  // ===== SHOP dropdown behavior =====
  (function initShopMenu(){
    const btnShop  = document.getElementById("btnShop");
    const shopMenu = document.getElementById("shopMenu");
    if(!btnShop || !shopMenu) return;

    function closeMenu(){ shopMenu.classList.add("hidden"); }
    function toggleMenu(){ shopMenu.classList.toggle("hidden"); }

    btnShop.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleMenu();
    });

    shopMenu.addEventListener("click", (e) => {
      const item = e.target.closest(".shopItem");
      if(!item) return;
      const url = item.getAttribute("data-url");
      if(url) window.open(url, "_blank", "noopener,noreferrer");
      closeMenu();
    });

    document.addEventListener("click", () => closeMenu());
    document.addEventListener("keydown", (e) => { if(e.key === "Escape") closeMenu(); });
  })();

  // =========================
  // TOOLS: Export / Import (MERGE)
  // =========================
  const deviceNameInput = document.getElementById("deviceName");
  const importFileEl = document.getElementById("importFile");
  const importReportEl = document.getElementById("importReport");
  const impOverwriteUPC = document.getElementById("impOverwriteUPC");
  const impMergeCats = document.getElementById("impMergeCats");

  function renderTools(){
    if(deviceNameInput && deviceNameInput.value !== state.deviceName){
      deviceNameInput.value = state.deviceName || "";
    }
  }

  deviceNameInput.addEventListener("change", () => {
    state.deviceName = normName(deviceNameInput.value) || "My Device";
    saveState(state);
    showToast("Device name saved.", 1400);
  });

  function nowStamp(){
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
  }

  function downloadJson(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 250);
  }

  function exportPayload(kind){
    const master = (state.masterGroceries || []).map(x => ({
      name: normName(x.name),
      catId: String(x.catId || "misc")
    })).filter(x => x.name);

    const dishes = (state.dishCatalog || []).map(d => ({
      name: normName(d.name),
      ingredients: Array.isArray(d.ingredients)
        ? d.ingredients.map(i => ({ name: normName(i.name), catId: String(i.catId || "misc") })).filter(i=>i.name)
        : []
    })).filter(d => d.name);

    const upc = state.upcDB && typeof state.upcDB === "object" ? state.upcDB : {};

    const base = {
      app: "grocery-app",
      schema: 2,
      exportedAt: new Date().toISOString(),
      deviceName: state.deviceName || "",
      appVersion: APP_VERSION
    };

    if(kind === "master") return { ...base, kind, masterGroceries: master };
    if(kind === "dishes") return { ...base, kind, dishCatalog: dishes };
    if(kind === "upc") return { ...base, kind, upcDB: upc };

    // all (recommended) ‚Äî includes categories
    return {
      ...base,
      kind: "all",
      masterGroceries: master,
      dishCatalog: dishes,
      upcDB: upc,
      categoryPrefs: state.categoryPrefs || { custom:{}, order:[] }
    };
  }

  document.getElementById("btnExportAll").onclick = () => {
    const payload = exportPayload("all");
    const fn = `grocery-app_ALL_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported ALL.", 1600);
  };
  document.getElementById("btnExportMaster").onclick = () => {
    const payload = exportPayload("master");
    const fn = `grocery-app_MASTER_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported Master.", 1600);
  };
  document.getElementById("btnExportDishes").onclick = () => {
    const payload = exportPayload("dishes");
    const fn = `grocery-app_DISHES_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported Dishes.", 1600);
  };
  document.getElementById("btnExportUPC").onclick = () => {
    const payload = exportPayload("upc");
    const fn = `grocery-app_UPC_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported UPC DB.", 1600);
  };

  document.getElementById("btnImport").onclick = () => {
    importFileEl.value = "";
    importFileEl.click();
  };

  function mergeCategoryPrefs(incoming){
    if(!incoming || typeof incoming !== "object") return { merged:false };

    const incCustom = incoming.custom && typeof incoming.custom === "object" ? incoming.custom : {};
    const incOrder = Array.isArray(incoming.order) ? incoming.order : [];

    let changed = false;

    // merge custom labels (don't overwrite local unless new id)
    Object.keys(incCustom).forEach(id => {
      const lbl = normName(incCustom[id]?.label || "");
      if(!lbl) return;

      if(!state.categoryPrefs.custom[id]){
        state.categoryPrefs.custom[id] = { label: lbl };
        changed = true;
      }
    });

    // merge order: keep local order, append unknown ids from imported order
    const local = Array.isArray(state.categoryPrefs.order) ? [...state.categoryPrefs.order] : [];
    const set = new Set(local);
    incOrder.forEach(id => {
      if(!set.has(id)){
        local.push(id);
        set.add(id);
        changed = true;
      }
    });
    state.categoryPrefs.order = local;

    if(changed) saveState(state);
    return { merged: changed };
  }

  function mergeMaster(imported){
    let added = 0, skipped = 0;
    const arr = Array.isArray(imported) ? imported : [];
    arr.forEach(x => {
      const name = normName(x?.name);
      let catId = String(x?.catId || "misc");

      // If older export had cat string, map it
      if(!x?.catId && x?.cat){
        catId = ensureCatForLabel(x.cat);
      }
      if(!name) return;
      const ok = addToMaster(name, catId);
      if(ok) added++; else skipped++;
    });
    return { added, skipped };
  }

  function mergeDishes(imported){
    let dishAdded = 0, dishUpdated = 0;
    let ingAdded = 0, ingSkipped = 0;

    const arr = Array.isArray(imported) ? imported : [];
    arr.forEach(d => {
      const dishName = normName(d?.name);
      if(!dishName) return;

      let local = getDishObjByName(dishName);
      if(!local){
        state.dishCatalog.push({ name: dishName, ingredients: [] });
        local = getDishObjByName(dishName);
        dishAdded++;
      }

      const incoming = Array.isArray(d?.ingredients) ? d.ingredients : [];
      const beforeCount = (local.ingredients || []).length;

      if(!Array.isArray(local.ingredients)) local.ingredients = [];

      const seen = new Set(local.ingredients.map(i =>
        normName(i.name).toLowerCase()+"|"+String(i.catId||"misc")
      ));

      incoming.forEach(i => {
        const inName = normName(i?.name);
        let inCatId = String(i?.catId || "misc");
        if(!i?.catId && i?.cat){
          inCatId = ensureCatForLabel(i.cat);
        }
        if(!inName) return;
        const key = inName.toLowerCase()+"|"+inCatId;
        if(seen.has(key)){
          ingSkipped++;
          return;
        }
        seen.add(key);
        local.ingredients.push({ name: inName, catId: inCatId });
        ingAdded++;
      });

      if((local.ingredients || []).length !== beforeCount){
        dishUpdated++;
      }
    });

    saveState(state);
    return { dishAdded, dishUpdated, ingAdded, ingSkipped };
  }

  function mergeUPC(imported, overwrite){
    let added = 0, updated = 0, skipped = 0;
    if(!state.upcDB || typeof state.upcDB !== "object") state.upcDB = {};

    const obj = imported && typeof imported === "object" ? imported : {};
    Object.keys(obj).forEach(code => {
      const clean = String(code||"").replace(/[^\d]/g,"").slice(0,32);
      if(!clean) return;

      const incoming = obj[code];
      const name = normName(incoming?.name);
      let catId = String(incoming?.catId || "misc");
      if(!incoming?.catId && incoming?.cat){
        catId = ensureCatForLabel(incoming.cat);
      }
      if(!name) return;

      const exists = state.upcDB[clean];
      if(!exists){
        state.upcDB[clean] = { name, catId };
        added++;
      } else {
        const same = normName(exists.name).toLowerCase()===name.toLowerCase()
          && String(exists.catId||"misc")===catId;

        if(same){
          skipped++;
        } else {
          if(overwrite){
            state.upcDB[clean] = { name, catId };
            updated++;
          } else {
            skipped++;
          }
        }
      }
    });

    saveState(state);
    return { added, updated, skipped };
  }

  importFileEl.addEventListener("change", async () => {
    const file = importFileEl.files?.[0];
    if(!file) return;

    try{
      const text = await file.text();
      const data = JSON.parse(text);

      const meta = {
        fromDevice: normName(data?.deviceName || "(unknown)"),
        exportedAt: data?.exportedAt || "(unknown)",
        kind: data?.kind || "(unknown)"
      };

      // Accept "all" or partials (master/dishes/upc)
      const m = data?.masterGroceries ?? data?.master ?? null;
      const d = data?.dishCatalog ?? data?.dishes ?? null;
      const u = data?.upcDB ?? data?.upc ?? null;

      const doUPCOverwrite = !!impOverwriteUPC.checked;

      let report = "";
      report += `IMPORT FILE: ${file.name}\n`;
      report += `FROM DEVICE: ${meta.fromDevice}\n`;
      report += `EXPORTED AT: ${meta.exportedAt}\n`;
      report += `KIND: ${meta.kind}\n\n`;

      // categories
      if(impMergeCats.checked && data?.categoryPrefs){
        const r = mergeCategoryPrefs(data.categoryPrefs);
        report += `CATEGORIES MERGE:\n  Merged: ${r.merged ? "YES" : "No changes"}\n\n`;
      } else {
        report += `CATEGORIES MERGE:\n  (Skipped)\n\n`;
      }

      let masterRes = null, dishRes = null, upcRes = null;

      if(m){
        masterRes = mergeMaster(m);
        report += `MASTER MERGE:\n  Added: ${masterRes.added}\n  Skipped (already exists): ${masterRes.skipped}\n\n`;
      } else {
        report += `MASTER MERGE:\n  (No master data in file)\n\n`;
      }

      if(d){
        dishRes = mergeDishes(d);
        report += `DISH CATALOG MERGE:\n  New dishes: ${dishRes.dishAdded}\n  Dishes updated: ${dishRes.dishUpdated}\n  Ingredients added: ${dishRes.ingAdded}\n  Ingredients skipped: ${dishRes.ingSkipped}\n\n`;
      } else {
        report += `DISH CATALOG MERGE:\n  (No dish data in file)\n\n`;
      }

      if(u){
        upcRes = mergeUPC(u, doUPCOverwrite);
        report += `UPC DB MERGE:\n  Added: ${upcRes.added}\n  Updated: ${upcRes.updated}\n  Skipped: ${upcRes.skipped}\n  Policy: ${doUPCOverwrite ? "OVERWRITE conflicts" : "SKIP conflicts"}\n\n`;
      } else {
        report += `UPC DB MERGE:\n  (No upc data in file)\n\n`;
      }

      debouncedRender();

      importReportEl.textContent = report.trim();
      showToast("Import merge complete.", 1800);

    } catch(err){
      console.warn("Import failed:", err);
      importReportEl.textContent = `Import failed.\n\n${String(err)}`;
      showToast("Import failed. Bad JSON?", 2000);
    }
  });

  // =========================
  // Initial render + default tab
  // =========================
  render();
  showTab("groceries");
  </script>
</body>
</html>
