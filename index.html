<!-- ============================================================
  VERSIONING REMINDER (READ BEFORE CHANGING CODE)
  ------------------------------------------------------------
  When making ANY functional change:

  1) Update APP_VERSION below (controls localStorage key)
  2) Update the visible build label in the header
  3) Update CACHE in sw.js
  4) Update start_url in manifest.webmanifest
  5) Commit ALL related files together

============================================================ -->

<!-- =========================
     index.html  (BUILD 070)
     ========================= -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grocery APP</title>
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    html, body { overflow-x: hidden; margin:0; }
    * { box-sizing: border-box; }

    :root{
      --navy:#0b1220;

      --primary:#2563eb;
      --primary2:#1d4ed8;
      --success:#16a34a;
      --success2:#15803d;
      --scan:#f59e0b;
      --scan2:#d97706;
      --danger:#ef4444;
      --danger2:#dc2626;

      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --soft:#f3f1ff;
      --soft2:#eef2ff;

      --border:rgba(15,23,42,.10);
      --shadow: 0 10px 26px rgba(2,6,23,.10);
      --shadow2: 0 14px 34px rgba(2,6,23,.12);

      --r-lg: 22px;
      --r-md: 18px;
      --r-pill: 999px;
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      background: linear-gradient(180deg, #fbfbff 0%, #f3f1ff 45%, #eef2ff 100%);
      color: var(--ink);
    }

    header{
      padding:14px 16px;
      background: linear-gradient(90deg, #0b1220 0%, #111827 55%, #0b1220 100%);
      color:#fff;
      font-weight:800;
      font-size:18px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      letter-spacing: .3px;
    }

    .wrap { padding:16px 14px 90px; max-width:820px; margin:0 auto; }

    .tabs{
      display:flex;
      gap:12px;
      margin-bottom:14px;
      align-items:center;
      flex-wrap:wrap;
    }

    .tabBtn{
      background: linear-gradient(180deg, #f4f2ff 0%, #ecebff 100%);
      color: var(--ink);
      border-radius: var(--r-pill);
      padding: 12px 20px;
      font-weight: 900;
      border: 1px solid rgba(15,23,42,.12);
      box-shadow: none;
      cursor:pointer;
    }

    .tabBtn.active{
      background: linear-gradient(180deg, #111827 0%, #0b1220 100%);
      color:#fff;
      border: 0;
      box-shadow: 0 12px 22px rgba(2,6,23,.18);
    }

    #btnClearDone{ margin-left:auto; }
    #btnMore{
      padding: 10px 14px;
      border-radius: var(--r-pill);
      font-weight: 900;
      line-height: 1;
      min-width: 48px;
    }

    .row { display:flex; gap:12px; flex-wrap:wrap; }

    .actionRow{
      justify-content: space-between;
    }
    .actionRow button{
      flex: 1 1 150px;
      min-width: 140px;
    }

    button{
      appearance:none;
      border:0;
      border-radius: var(--r-md);
      padding: 14px 18px;
      font-size: 16px;
      font-weight: 900;
      cursor: pointer;
      color:#fff;
      background: linear-gradient(180deg, var(--primary) 0%, var(--primary2) 100%);
      box-shadow: var(--shadow);
      transition: transform .08s ease, filter .12s ease, box-shadow .12s ease;
      letter-spacing: .2px;
    }

    button:active{ transform: translateY(1px); }
    button:hover{ filter: brightness(1.03); box-shadow: var(--shadow2); }
    button:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; filter:none; }

    button.secondary{
      background: linear-gradient(180deg, #f4f2ff 0%, #ecebff 100%);
      color: var(--ink);
      border: 1px solid rgba(15,23,42,.12);
      box-shadow: 0 10px 18px rgba(2,6,23,.06);
    }

    button.danger{
      background: linear-gradient(180deg, var(--danger) 0%, var(--danger2) 100%);
      color:#fff;
      box-shadow: 0 12px 22px rgba(239,68,68,.16);
    }

    button.scanQR{
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
    }
    button.scanUPC{
      background: linear-gradient(180deg, var(--scan) 0%, var(--scan2) 100%);
      box-shadow: 0 10px 18px rgba(245,158,11,.22);
    }

    #btnUndo{
      min-width: 60px !important;
      padding-left: 6px;
      padding-right: 6px;
      background: linear-gradient(180deg, #a78bfa 0%, #7c3aed 100%) !important;
      color:#fff !important;
      border:0 !important;
      box-shadow: 0 12px 22px rgba(124,58,237,.18) !important;
    }

    #btnAdd{
      background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%) !important;
      color:#fff !important;
      border:0 !important;
      box-shadow: 0 12px 22px rgba(34,197,94,.18) !important;
    }
    #btnMasterAddSelected{
      background: linear-gradient(180deg, #14b8a6 0%, #0d9488 100%) !important;
      color:#fff !important;
      border:0 !important;
      box-shadow: 0 12px 22px rgba(20,184,166,.18) !important;
    }

    .card{
      background: var(--card);
      border-radius: var(--r-lg);
      padding:12px;
      margin-top:12px;
      border: 1px solid rgba(15,23,42,.08);
      box-shadow: 0 16px 34px rgba(2,6,23,.10);
    }

    .muted { color: var(--muted); }
    .spacer { height:10px; }
    .total { font-weight:900; font-size:18px; letter-spacing:.2px; }

    .pill,
    .catPill{
      font-size:12px; font-weight:900;
      padding:6px 10px; border-radius:999px;
      background:#e5e7eb; color:#111827;
      white-space:nowrap;
      border: 1px solid rgba(15,23,42,.10);
    }
    .pill.ok{ background:rgba(34,197,94,.18); color:#065f46; }
    .pill.warn{ background:rgba(245,158,11,.18); color:#92400e; }

    .item {
      display:flex; align-items:center; gap:10px;
      padding:10px 6px; border-bottom:1px solid #eee;
    }
    .item:last-child { border-bottom:0; }
    .check { width:26px; height:26px; }
    .name { flex:1; font-size:16px; cursor:pointer; }
    .done .name { text-decoration: line-through; opacity:.55; }
    .qty { width:64px; padding:8px 10px; border:1px solid #ddd; border-radius:12px; font-size:16px; }
    select { padding:8px 10px; border:1px solid #ddd; border-radius:12px; font-size:16px; background:#fff; }
    .price { width:96px; padding:8px 10px; border:1px solid #ddd; border-radius:12px; font-size:16px; }

    .masterRow{
      display:flex; align-items:center; gap:10px;
      padding:10px 6px; border-bottom:1px solid #eee;
    }
    .masterRow:last-child{ border-bottom:0; }
    .mName{ flex:1; font-size:16px; cursor:pointer; font-weight:800; }
    .mCheck{ width:26px; height:26px; }

    .dishRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 6px; border-bottom:1px solid #eee;
    }
    .dishRow:last-child{ border-bottom:0; }
    .dishName{ font-size:16px; font-weight:800; cursor:pointer; }

    .delBtn{
      background: rgba(239,68,68,.10);
      color:#7f1d1d;
      padding:10px 12px;
      border-radius: 14px;
      font-weight: 900;
      box-shadow:none;
      border: 1px solid rgba(239,68,68,.18);
    }
    .delBtn:hover{ filter: brightness(1.02); }

    .modalBg {
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:16px;
      z-index: 9999;
    }
    .modal {
      width:min(760px, 100%);
      max-width: calc(100vw - 32px);
      background:#fff; border-radius:18px; overflow:hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
      max-height: calc(100dvh - 32px);
      display:flex; flex-direction:column;
    }
    .modalHead {
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px; background:#111827; color:#fff;
    }
    .modalBody {
      padding:12px; display:flex; flex-direction:column; gap:10px;
      overflow-y:auto; overscroll-behavior: contain;
      padding-bottom: env(safe-area-inset-bottom, 12px);
    }
    #reader {
      width:100%; max-height:50dvh; overflow:hidden; border-radius:16px; background:#000;
    }
    #reader * { max-width:100% !important; box-sizing:border-box; }
    #reader video,
    #reader canvas {
      width:100% !important; height:auto !important;
      max-height:50dvh !important; object-fit:contain;
      border-radius:16px; display:block;
    }
    .hint { color:#6b7280; font-size:14px; margin-top:0; }
    .scanBar {
      margin-top:10px; background:rgba(17,24,39,.06);
      border:1px solid rgba(17,24,39,.10); border-radius:14px;
      padding:10px 12px; display:flex; align-items:center;
      justify-content:space-between; gap:10px; flex-wrap:wrap;
      position:sticky; bottom:0; z-index:5; background:#fff;
      box-shadow:0 -6px 18px rgba(0,0,0,.06);
    }
    .scanMsg {
      font-weight:900; font-size:16px; color:#111827;
      flex:1; min-width:0; overflow-wrap:anywhere;
    }
    .scanMsg.ok { color:#065f46; }
    .scanMsg.warn { color:#92400e; }
    .scanBtns { display:flex; gap:10px; flex-wrap:wrap; flex:0 0 auto; }
    .capBtn { background:#16a34a; }
    .doneBtn { background:#e5e7eb; color:#111827; }

    .miniBg{
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:16px;
      z-index: 9998;
    }

    .ingRow{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .ingRow input{
      flex:1;
      padding:12px 12px;
      border:1px solid #ddd;
      border-radius:14px;
      font-size:16px;
    }
    .ingRow select{
      width:160px;
      padding:12px 12px;
      border:1px solid #ddd;
      border-radius:14px;
      font-size:16px;
      background:#fff;
    }
    .ingRow .delBtn{ padding:10px 12px; }

    .mini{
      width:min(520px, 100%);
      background:#fff; border-radius:18px; overflow:hidden;
      box-shadow:0 20px 60px rgba(0,0,0,.35);
      max-height: calc(100dvh - 32px);
      display:flex; flex-direction:column;
    }
    .miniHead{
      padding:12px 14px; background:#111827; color:#fff;
      display:flex; justify-content:space-between; align-items:center;
      font-weight:900;
      flex: 0 0 auto;
    }
    .miniBody{
      padding:12px 14px; display:flex; flex-direction:column; gap:10px;
      overflow-y:auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      min-height: 0;
    }
    .miniBtns{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
      padding:0 14px 14px;
      flex: 0 0 auto;
    }

    .toolRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .toolRow button{ flex: 1 1 220px; min-width: 200px; }
    .smallNote{ font-size: 13px; color: var(--muted); line-height: 1.35; }
    .reportBox{
      white-space: pre-wrap;
      background: rgba(17,24,39,.04);
      border: 1px solid rgba(17,24,39,.10);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 13px;
      color: #111827;
    }
    .toggleRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding: 10px 12px;
      border: 1px solid rgba(15,23,42,.10);
      border-radius: 14px;
      background: rgba(255,255,255,.7);
    }
    .toggleRow label{
      display:flex; align-items:center; gap:10px;
      font-weight: 900;
    }
    .toggleRow input[type="checkbox"]{ width: 22px; height: 22px; }

    /* ===== SHOP menu (two-stage) ===== */
    .shopWrap{
      position: relative;
      display: inline-block;
      margin-left: 20px;
    }

    .shopMenu{
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 200px;
      padding: 8px;
      background: #fff;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      z-index: 9999;
    }
    .shopSubMenu{
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 180px;
      padding: 8px;
      background: #fff;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      z-index: 10000;
    }
    .shopSubMenu.hidden{ display:none; }

    .shopMenu.hidden{ display: none; }

    .shopItem{
      width: 100%;
      padding: 10px 12px;
      text-align: left;
      border: 0;
      background: transparent;
      cursor: pointer;
      color: #000;
      font-weight: 900;
      border-radius: 8px;
    }
    .shopItem:hover{ background: rgba(0,0,0,.08); }

    .shopItem.active{
      outline: 2px solid rgba(37,99,235,.25);
      background: rgba(37,99,235,.10);
    }

    .shopSubHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 6px 6px 10px 6px;
      border-bottom: 1px solid rgba(0,0,0,.10);
      margin-bottom: 8px;
      font-weight: 900;
      color:#111827;
    }

    .shopBackBtn{
      padding:8px 10px;
      border-radius:10px;
      background: rgba(17,24,39,.06);
      color:#111827;
      border: 1px solid rgba(0,0,0,.12);
      box-shadow:none;
      cursor:pointer;
      font-weight: 900;
    }

    /* ===== Category manager rows ===== */
    .catMgrList{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top: 6px;
      padding-bottom: 8px;
    }
    .catMgrRow{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 10px;
      border: 1px solid rgba(15,23,42,.10);
      border-radius: 14px;
      background: rgba(255,255,255,.85);
    }
    .dragHandle{
      font-size: 20px;
      width: 28px;
      text-align:center;
      cursor: grab;
      user-select:none;
      opacity:.75;
    }
    .catNameInput{
      flex:1;
      padding:10px 10px;
      border:1px solid #ddd;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 900;
    }
    .catBadge{
      font-size: 12px;
      font-weight: 900;
      padding:6px 10px;
      border-radius:999px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(17,24,39,.05);
      color:#111827;
      white-space:nowrap;
    }
    .catBadge.builtIn{ background: rgba(34,197,94,.12); border-color: rgba(34,197,94,.22); color:#065f46; }

    /* ===== iOS Safari fallback for dvh ===== */
    @supports not (height: 100dvh){
      .mini{ max-height: calc(100vh - 32px); }
      .modal{ max-height: calc(100vh - 32px); }
    }
  </style>

  <script src="https://unpkg.com/html5-qrcode"></script>
</head>

<body>
  <header>Grocery APP <span style="opacity:.7;font-weight:600;">(Build 070)</span></header>

  <div class="wrap">
    <div class="tabs">
      <button id="tabGroceries" class="tabBtn active">Groceries</button>
      <button id="tabDishes" class="tabBtn">Dishes</button>

      <button id="btnMore" class="secondary" title="More / Import / Export">‚ãØ</button>
      <button id="btnClearDone" class="secondary">Clear Purchased</button>
    </div>

    <!-- GROCERIES TAB -->
    <div id="screenGroceries">
      <div class="row actionRow">
        <button id="btnNew">New List</button>
        <button id="btnScan" class="scanQR">SCAN QR</button>
        <button id="btnScanUPC" class="scanUPC">SCAN UPC</button>
        <button id="btnAdd" class="secondary">Add Item</button>
        <button id="btnUndo" class="secondary">Undo</button>

        <!-- CATS -->
        <button id="btnCats" class="secondary">CATS</button>

        <!-- SHOP button + dropdown -->
        <div class="shopWrap">
          <button id="btnShop" class="secondary">SHOP</button>

          <!-- Main store list -->
          <div id="shopMenu" class="shopMenu hidden" role="menu" aria-label="Shop">
            <!-- built by JS -->
          </div>
            <div id="shopSubMenu" class="shopSubMenu hidden" role="menu" aria-label="Store actions">
              <button class="shopItem subAction" data-action="sort" role="menuitem">Sort</button>
                <button class="shopItem subAction" data-action="site" role="menuitem">Site</button>
              <button class="shopItem subAction" data-action="edit" role="menuitem">Edit Order</button>
            </div>

          <!-- Submenu: Sort / Edit Order / Site -->
          <div id="shopSubMenu" class="shopMenu hidden" role="menu" aria-label="Shop store options">
            <!-- built by JS -->
          </div>
        </div>
      </div>

      <!-- Shopping list summary -->
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div>
            <b>Shopping List:</b> <span id="listName">Today</span><br>
            <span class="muted">Sorted by store walking order + name.</span>
          </div>
          <div class="total">Total: $<span id="total">0.00</span></div>
        </div>

        <div class="spacer"></div>

        <!-- Active sort indicator -->
        <div id="sortIndicator" style="display:none; align-items:center; gap:10px; flex-wrap:wrap;">
          <span class="pill ok" id="sortIndicatorText">Sorted for: Default</span>
          <button id="btnClearStoreSort" class="secondary" style="padding:10px 12px; border-radius:12px;">√ó</button>
          <span class="muted" style="font-size:13px;">Tap √ó to return to Default order.</span>
        </div>
      </div>

      <div class="card" id="listCard"></div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div>
            <b>Master Grocery List:</b>
            <span class="pill"><span id="masterCount">0</span> items</span>
          </div>
          <div class="muted">Check items here, then tap <b>ADD SELECTED</b>.</div>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <button id="btnMasterAddSelected" class="secondary">ADD SELECTED</button>
          <button id="btnMasterClearChecks" class="secondary">CLEAR CHECKS</button>
          <button id="btnMasterClear" class="danger">Clear Master</button>
        </div>

        <div class="spacer"></div>
        <div id="masterCard"></div>
      </div>
    </div>

    <!-- DISHES TAB -->
    <div id="screenDishes" style="display:none;">
      <div class="row">
        <button id="btnScanDish">SCAN DISH</button>
        <button id="btnAddDish" class="secondary">Add Dish</button>
        <button id="btnRandom14" class="secondary">Random Menu (14)</button>
        <button id="btnAddCheckedIng" class="secondary">Add ING. To Shopping List</button>
        <button id="btnClearMenu" class="secondary">Clear Menu</button>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div><b>Current Menu:</b> <span class="pill ok"><span id="menuCount">0</span> dishes</span></div>
          <div class="muted">Scanning a dish adds it to Menu + Catalog.</div>
        </div>
      </div>
      <div class="card" id="menuCard"></div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div><b>Dish Catalog:</b> <span class="pill"><span id="catalogCount">0</span> total</span></div>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
            <div class="muted">Tap a dish to rename; delete button removes menu/catalog.</div>
            <button id="btnClearCatalog" class="danger">Clear Catalog</button>
          </div>
        </div>

        <div class="spacer"></div>
        <div id="catalogCard"></div>
      </div>
    </div>

    <!-- TOOLS / IMPORT EXPORT SCREEN -->
    <div id="screenTools" style="display:none;">
      <div class="row">
        <button id="btnToolsBack" class="secondary">‚Üê Back</button>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div><b>More / Tools</b></div>
          <div class="muted">Export/Import for multi-device manual sync.</div>
        </div>

        <div class="spacer"></div>

        <div class="miniRow">
          <label for="deviceName">Device name (included in export file)</label>
          <input id="deviceName" type="text" placeholder="e.g., Dave-iPhone, Kitchen-iPad, Laptop" />
          <div class="smallNote">Tip: Use a unique name per device so you can tell exports apart.</div>
        </div>
      </div>

      <div class="card">
        <b>Export</b>
        <div class="spacer"></div>
        <div class="toolRow">
          <button id="btnExportAll" class="secondary">Export ALL (recommended)</button>
          <button id="btnExportMaster" class="secondary">Export Master Groceries</button>
          <button id="btnExportDishes" class="secondary">Export Dish Catalog</button>
          <button id="btnExportUPC" class="secondary">Export UPC DB</button>
        </div>
        <div class="spacer"></div>
        <div class="smallNote">
          Export creates a JSON file you can AirDrop/email/text to your other device, then import there.
        </div>
      </div>

      <div class="card">
        <b>Import (MERGE)</b>
        <div class="spacer"></div>

        <div class="toggleRow">
          <label><input id="impOverwriteUPC" type="checkbox"> Overwrite UPC conflicts (default: skip conflicts)</label>
        </div>

        <div class="spacer"></div>

        <div class="toolRow">
          <button id="btnImport" class="secondary">Import JSON (merge)</button>
        </div>

        <input id="importFile" type="file" accept=".json,application/json" style="display:none;" />

        <div class="spacer"></div>
        <div class="reportBox" id="importReport">No import yet.</div>
      </div>
    </div>
  </div>

  <!-- Scanner Modal -->
  <div class="modalBg" id="modalBg">
    <div class="modal">
      <div class="modalHead">
        <div><b id="scanTitle">Scan</b></div>
        <button id="btnCloseTop" class="secondary" style="padding:10px 12px; border-radius:12px;">Close</button>
      </div>
      <div class="modalBody">
        <div id="reader"></div>
        <div class="scanBar">
          <div id="scanMsg" class="scanMsg">Point camera at code ‚Äì hold steady‚Ä¶</div>
          <div class="scanBtns">
            <button id="btnCapture" class="capBtn" disabled>CAPTURE</button>
            <button id="btnDone" class="doneBtn">DONE</button>
          </div>
        </div>
        <div class="hint" id="scanHint">
          Tip: Fill the capture box with the code and hold steady.
        </div>
      </div>
    </div>
  </div>

  <!-- Add/Edit Item Modal -->
  <div class="miniBg" id="miniBg">
    <div class="mini">
      <div class="miniHead">
        <div id="miniTitle">Add Item</div>
        <button id="miniClose" class="secondary" style="padding:10px 12px; border-radius:12px;">X</button>
      </div>
      <div class="miniBody">
        <div class="miniRow">
          <label for="miniName">Item name</label>
          <input id="miniName" type="text" placeholder="e.g., Milk" />
        </div>
        <div class="miniRow">
          <label for="miniCat">Category</label>
          <select id="miniCat"></select>
        </div>
      </div>
      <div class="miniBtns">
        <button id="miniCancel" class="secondary">Cancel</button>
        <button id="miniOk">OK</button>
      </div>
    </div>
  </div>

  <!-- Dish Ingredients Modal (PHASE 2) -->
  <div class="miniBg" id="dishBg" style="display:none;">
    <div class="mini">
      <div class="miniHead">
        <div id="dishTitle">Dish Ingredients</div>
        <button id="dishClose" class="secondary" style="padding:10px 12px; border-radius:12px;">X</button>
      </div>

      <div class="miniBody" style="gap:12px;">
        <div class="muted" style="font-size:14px;">
          Add ingredients for this dish. These will be used when you ‚ÄúAdd ING. To Shopping List‚Äù.
        </div>

        <div id="dishIngList" style="display:flex; flex-direction:column; gap:10px;"></div>

        <button id="dishAddIng" class="secondary" type="button">+ Add Ingredient</button>
      </div>

      <div class="miniBtns">
        <button id="dishCancel" class="secondary" type="button">Cancel</button>
        <button id="dishSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- Categories Manager (CATS) -->
  <div class="miniBg" id="catBg">
    <div class="mini">
      <div class="miniHead">
        <div id="catTitle">Manage Categories</div>
        <button id="catCloseX" class="secondary" style="padding:10px 12px; border-radius:12px;">X</button>
      </div>
      <div class="miniBody">
        <div class="muted" style="font-size:14px;">
          Drag to reorder (walking order) for the selected store context. Rename any category. Delete custom categories (items move to Misc).
        </div>

        <div class="muted" id="catContextLine" style="font-size:13px; font-weight:900;">
          Editing order for: Default (All Stores)
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <input id="catNewName" type="text" placeholder="New category name‚Ä¶" style="flex:1; min-width:220px; padding:12px; border:1px solid #ddd; border-radius:14px; font-size:16px;">
          <button id="catAddBtn" class="secondary" type="button" style="min-width:160px;">+ Add Category</button>
          <button id="catCopyDefaultBtn" class="secondary" type="button" style="min-width:180px; display:none;">Copy Default ‚Üí This Store</button>
        </div>

        <div class="catMgrList" id="catMgrList"></div>
      </div>
      <div class="miniBtns">
        <button id="catCancel" class="secondary" type="button">Close</button>
        <button id="catSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <script>
  // =========================
  // Consistency: Build / Version
  // =========================
  const APP_VERSION = 70;

  // Service worker registration
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("sw.js").catch(console.warn);
  }

  // =========================
  // Helpers
  // =========================
  function money(n) { return (Math.round((n||0)*100)/100).toFixed(2); }

  function generateId() {
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }

  function escapeHtml(s) {
    return String(s ?? "").replace(/[&<>"']/g, m => ({
      "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;"
    }[m]));
  }

  function normName(s){ return String(s ?? "").trim().replace(/\s+/g, " "); }

  function showToast(message, duration = 2000) {
    const div = document.createElement('div');
    div.textContent = message;
    div.style.cssText = `
      position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
      background: #111827; color: white; padding: 12px 24px;
      border-radius: 12px; z-index: 10000; font-weight: 700;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25); pointer-events: none;
      max-width: calc(100vw - 24px); text-align:center;
    `;
    document.body.appendChild(div);
    setTimeout(() => div.remove(), duration);
  }

  function loadState(key) {
    try { return JSON.parse(localStorage.getItem(key)) || null; }
    catch { return null; }
  }
  function saveState(key, s) { localStorage.setItem(key, JSON.stringify(s)); }

  function newBlankList(name) { return { name, items: [], created: Date.now() }; }

  // =========================
  // Build constants
  // =========================
  const LS_KEY = `groceryApp_v${APP_VERSION}`;
  const UNITS = ["ea","lb","oz","gal","ct"];

  // ===== Stores =====
  // NOTE: store list is fixed by code, but per-store ORDER is stored in state.
  const STORES = [
    { id:"__default__", name:"Default (All Stores)", url:"" },
    { id:"walmart", name:"Walmart", url:"https://www.walmart.com/" },
    { id:"publix",  name:"Publix",  url:"https://www.publix.com/" },
    { id:"kroger",  name:"Kroger",  url:"https://www.kroger.com/" },
    { id:"ingles",  name:"Ingles",  url:"https://www.ingles-markets.com/" }
  ];

  function storeById(id){ return STORES.find(s => s.id === id) || STORES[0]; }

  // ===== Categories (catalog) =====
  // Items store BOTH catId + catName (hybrid, your choice #3=C)
  const DEFAULT_CATS = [
    { id:"produce",    name:"Produce",    builtIn:true },
    { id:"deli",       name:"Deli",       builtIn:true },
    { id:"bakery",     name:"Bakery",     builtIn:true },
    { id:"seafood",    name:"Seafood",    builtIn:true },
    { id:"beef",       name:"Beef",       builtIn:true },
    { id:"pork",       name:"Pork",       builtIn:true },
    { id:"chicken",    name:"Chicken",    builtIn:true },
    { id:"dairy",      name:"Dairy",      builtIn:true },
    { id:"cheese",     name:"Cheese",     builtIn:true },
    { id:"beerwine",   name:"Beer/Wine",  builtIn:true },
    { id:"beverages",  name:"Beverages",  builtIn:true },
    { id:"snacks",     name:"Snacks",     builtIn:true },
    { id:"frozen",     name:"Frozen",     builtIn:true },
    { id:"household",  name:"Household",  builtIn:true },
    { id:"baking",     name:"Baking",     builtIn:true },
    { id:"canveggies", name:"Can Vegies", builtIn:true },
    { id:"canmeat",    name:"Can Meat",   builtIn:true },
    { id:"condiments", name:"Condiments", builtIn:true },
    { id:"bread",      name:"Bread",      builtIn:true },
    { id:"pet",        name:"Pet",        builtIn:true },
    { id:"pharmacy",   name:"Pharmacy",   builtIn:true },
    { id:"misc",       name:"Misc",       builtIn:true }
  ];

  function slugIdFromName(name){
    name = normName(name).toLowerCase();
    name = name.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g,"");
    if(!name) name = "cat";
    return name.slice(0, 32);
  }

  // =========================
  // Smart one-time migration helper (v70 looks back)
  // =========================
  function smartMigrateLocalStorage({ maxLookback = 40 } = {}) {
    const newKey = `groceryApp_v${APP_VERSION}`;
    const flagKey = `groceryApp_migrated_to_${newKey}`;

    if (localStorage.getItem(newKey)) return false;
    if (localStorage.getItem(flagKey) === "1") return false;

    for (let v = APP_VERSION - 1; v >= Math.max(1, APP_VERSION - maxLookback); v--) {
      const oldKey = `groceryApp_v${v}`;
      const oldData = localStorage.getItem(oldKey);
      if (!oldData) continue;

      try {
        JSON.parse(oldData);
        localStorage.setItem(newKey, oldData);
        localStorage.setItem(flagKey, "1");
        console.log(`[MIGRATE] Copied ${oldKey} -> ${newKey}`);
        return true;
      } catch (e) {
        console.warn(`[MIGRATE] Invalid data in ${oldKey}, skipping`, e);
      }
    }
    return false;
  }
  smartMigrateLocalStorage();

  // =========================
  // State
  // =========================
  let state = loadState(LS_KEY) || {
    current: newBlankList("Today"),
    dishCatalog: [],
    currentMenu: [],
    masterGroceries: [],
    upcDB: {},
    deviceName: "",
    menuAddFlags: {},

    // v70 additions
    categories: [],
    defaultOrder: [],
    storeOrders: {},          // { [storeId]: [catId,...] }
    activeStoreId: "__default__"
  };

  // Ensure deviceName exists
  if(typeof state.deviceName !== "string") state.deviceName = "";
  if(!state.deviceName.trim()){
    const plat = (navigator.platform || "").replace(/\s+/g," ").trim();
    state.deviceName = plat ? plat : "My Device";
  }

  // =========================
  // v70: Category / Store Order Migration + Normalization
  // =========================
  function ensureV70CategoryModel(){
    let changed = false;

    // categories catalog
    if(!Array.isArray(state.categories) || state.categories.length === 0){
      state.categories = DEFAULT_CATS.map(x => ({...x}));
      changed = true;
    } else {
      // ensure required fields
      state.categories = state.categories
        .map(c => ({
          id: String(c?.id || "").trim(),
          name: normName(c?.name || ""),
          builtIn: !!c?.builtIn
        }))
        .filter(c => c.id && c.name);
    }

    // Ensure misc exists and is builtIn
    if(!state.categories.some(c => c.id === "misc")){
      state.categories.push({ id:"misc", name:"Misc", builtIn:true });
      changed = true;
    }

    // defaultOrder
    if(!Array.isArray(state.defaultOrder) || state.defaultOrder.length === 0){
      state.defaultOrder = DEFAULT_CATS.map(c => c.id);
      changed = true;
    }

    // storeOrders map
    if(!state.storeOrders || typeof state.storeOrders !== "object"){
      state.storeOrders = {};
      changed = true;
    }

    // active store
    if(typeof state.activeStoreId !== "string" || !state.activeStoreId){
      state.activeStoreId = "__default__";
      changed = true;
    }
    if(!storeById(state.activeStoreId)) state.activeStoreId = "__default__";

    // Build fast lookup for name->id
    const nameToId = {};
    state.categories.forEach(c => { nameToId[c.name.toLowerCase()] = c.id; });

    // Migrate old items that used item.cat (string) to catId + catName
    const fixItemCat = (it) => {
      if(!it) return it;

      // If already hybrid
      if(it.catId && it.catName){
        it.catId = String(it.catId);
        it.catName = normName(it.catName) || "Misc";
        return it;
      }

      // Old format: it.cat (string)
      const oldName = normName(it.cat || it.catName || "Misc") || "Misc";
      const id = nameToId[oldName.toLowerCase()] || (oldName.toLowerCase()==="misc" ? "misc" : null);

      if(id){
        it.catId = id;
        it.catName = oldName;
        delete it.cat; // optional cleanup
        changed = true;
        return it;
      }

      // Unknown category name from old data -> create custom category
      // (keeps your data safe)
      const newIdBase = slugIdFromName(oldName);
      let newId = newIdBase;
      let n = 2;
      while(state.categories.some(c => c.id === newId)) { newId = `${newIdBase}-${n++}`; }

      state.categories.push({ id:newId, name: oldName, builtIn:false });
      it.catId = newId;
      it.catName = oldName;
      delete it.cat;
      changed = true;
      return it;
    };

    // current list items
    if(state.current && Array.isArray(state.current.items)){
      state.current.items = state.current.items.map(fixItemCat);
    }

    // masterGroceries entries (old had {name,cat})
    if(Array.isArray(state.masterGroceries)){
      state.masterGroceries = state.masterGroceries.map(m => {
        if(!m) return m;

        // already hybrid entry
        if(m.catId && m.catName){
          m.catId = String(m.catId);
          m.catName = normName(m.catName) || "Misc";
          return m;
        }

        const oldName = normName(m.cat || m.catName || "Misc") || "Misc";
        let id = nameToId[oldName.toLowerCase()] || (oldName.toLowerCase()==="misc" ? "misc" : null);
        if(!id){
          const base = slugIdFromName(oldName);
          let nid = base, k=2;
          while(state.categories.some(c => c.id === nid)) nid = `${base}-${k++}`;
          state.categories.push({ id:nid, name: oldName, builtIn:false });
          id = nid;
          changed = true;
        }
        return { name: normName(m.name), catId: id, catName: oldName };
      }).filter(x => x && normName(x.name));
      changed = true;
    }

    // dish catalog migration (string -> object) + ingredients cat model
    (function migrateDishData(){
      let dishChanged = false;

      state.dishCatalog = (state.dishCatalog || []).map(d => {
        if (typeof d === "string") {
          dishChanged = true;
          return { name: d, ingredients: [] };
        }
        if (!d || typeof d !== "object") {
          dishChanged = true;
          return { name: String(d ?? ""), ingredients: [] };
        }
        if (!("name" in d)) {
          dishChanged = true;
          d.name = String(d.name ?? "");
        }
        if (!Array.isArray(d.ingredients)) {
          dishChanged = true;
          d.ingredients = [];
        }

        // migrate ingredients {name,cat} -> {name,catId,catName}
        d.ingredients = (d.ingredients || []).map(ing => {
          if(!ing) return ing;
          if(ing.catId && ing.catName){
            return { name: normName(ing.name), catId: String(ing.catId), catName: normName(ing.catName)||"Misc" };
          }
          const oldName = normName(ing.cat || ing.catName || "Misc") || "Misc";
          let id = nameToId[oldName.toLowerCase()] || "misc";
          return { name: normName(ing.name), catId: id, catName: oldName };
        }).filter(x => x && normName(x.name));

        return d;
      }).filter(d => normName(d.name));

      state.currentMenu = (state.currentMenu || [])
        .map(d => typeof d === "string" ? d : d?.name)
        .filter(Boolean);

      if (dishChanged) {
        console.log("[v70] Dish data migrated");
        changed = true;
      }
    })();

    // Normalize orders: ensure every order includes all category ids (append missing before misc)
    function normalizeOrder(order){
      const ids = state.categories.map(c => c.id);
      const seen = new Set();
      const out = [];

      // Keep known ids in existing order
      (order || []).forEach(id => {
        id = String(id||"");
        if(!id) return;
        if(!ids.includes(id)) return; // skip removed cats
        if(seen.has(id)) return;
        seen.add(id);
        out.push(id);
      });

      // Ensure "misc" exists; we want missing cats to go BEFORE misc when possible.
      const hasMisc = out.includes("misc");

      // Append missing ids (except misc) before misc
      const missing = ids.filter(id => id !== "misc" && !seen.has(id));
      if(missing.length){
        if(hasMisc){
          const iMisc = out.indexOf("misc");
          out.splice(iMisc, 0, ...missing);
        } else {
          out.push(...missing);
        }
      }

      // Ensure misc last
      if(!out.includes("misc")) out.push("misc");
      else {
        // move misc to end
        out.splice(out.indexOf("misc"), 1);
        out.push("misc");
      }

      return out;
    }

    state.defaultOrder = normalizeOrder(state.defaultOrder);

    // For each store (non-default), keep an independent order when created
    Object.keys(state.storeOrders).forEach(sid => {
      state.storeOrders[sid] = normalizeOrder(state.storeOrders[sid]);
    });

    if(changed){
      saveState(LS_KEY, state);
    }
  }

  ensureV70CategoryModel();

  // =========================
  // Category + Store Order Helpers
  // =========================
  function getOrderForStore(storeId){
    if(storeId === "__default__") return state.defaultOrder;
    if(state.storeOrders && Array.isArray(state.storeOrders[storeId])) return state.storeOrders[storeId];
    return null;
  }

  function ensureStoreOrderExists(storeId){
    if(storeId === "__default__") return;
    if(!state.storeOrders) state.storeOrders = {};
    if(!Array.isArray(state.storeOrders[storeId])){
      // First time: copy default into store order (then independent)
      state.storeOrders[storeId] = [...state.defaultOrder];
      saveState(LS_KEY, state);
    }
  }

  function catById(id){
    return state.categories.find(c => c.id === id) || state.categories.find(c => c.id === "misc");
  }

  function catNameFromId(id){
    return catById(id)?.name || "Misc";
  }

  function getActiveOrder(){
    const sid = state.activeStoreId || "__default__";
    return getOrderForStore(sid) || state.defaultOrder;
  }

  function catIndexInActiveOrder(catId){
    const order = getActiveOrder();
    const i = order.indexOf(catId);
    return i === -1 ? order.length + 999 : i;
  }

  function sortByStoreOrderThenName(a, b){
    const ai = catIndexInActiveOrder(a.catId || "misc");
    const bi = catIndexInActiveOrder(b.catId || "misc");
    if(ai !== bi) return ai - bi;

    const an = normName(a.name).toLowerCase();
    const bn = normName(b.name).toLowerCase();
    if(an < bn) return -1;
    if(an > bn) return 1;
    return 0;
  }

  // =========================
  // State helpers
  // =========================
  function computeTotal() {
    return state.current.items.reduce((sum, it) => {
      const p = parseFloat(it.price) || 0;
      const q = parseFloat(it.qty) || 1;
      return sum + p * q;
    }, 0);
  }

  function sameItem(a, b){
    const an = normName(a.name).toLowerCase();
    const bn = normName(b.name).toLowerCase();
    const ac = String(a.catId || "misc");
    const bc = String(b.catId || "misc");
    return an === bn && ac === bc;
  }
  function hasItem(arr, cand){ return arr.some(x => sameItem(x, cand)); }

  function sameDishName(a, b){
    return normName(a).toLowerCase() === normName(b).toLowerCase();
  }
  function hasDish(arr, name){
    return (arr||[]).some(x => sameDishName(x, name));
  }

  function dishKey(name){ return encodeURIComponent(String(name ?? "")); }
  function undishKey(k){
    try { return decodeURIComponent(String(k ?? "")); } catch { return String(k ?? ""); }
  }

  // =========================
  // Add/Edit Item Modal
  // =========================
  const miniBg = document.getElementById("miniBg");
  const miniTitle = document.getElementById("miniTitle");
  const miniName = document.getElementById("miniName");
  const miniCat = document.getElementById("miniCat");
  let miniResolve = null;

  function buildCatOptions(selectedCatId){
    const sel = String(selectedCatId || "misc");
    // Use ACTIVE order list for display (nice UX)
    const order = getActiveOrder();
    const orderedCats = order
      .map(id => catById(id))
      .filter(Boolean);

    miniCat.innerHTML = orderedCats.map(c =>
      `<option value="${escapeHtml(c.id)}" ${c.id===sel ? "selected":""}>${escapeHtml(c.name)}</option>`
    ).join("");
  }

  function openItemModal(title, defaults = {name:"", catId:"misc"}){
    miniTitle.textContent = title;
    miniName.value = defaults.name || "";
    buildCatOptions(defaults.catId || "misc");
    miniBg.style.display = "flex";
    setTimeout(()=> miniName.focus(), 80);
    return new Promise(resolve => { miniResolve = resolve; });
  }

  function closeItemModal(result){
    miniBg.style.display = "none";
    const r = miniResolve;
    miniResolve = null;
    if(r) r(result);
  }

  document.getElementById("miniClose").onclick = () => closeItemModal(null);
  document.getElementById("miniCancel").onclick = () => closeItemModal(null);
  document.getElementById("miniOk").onclick = () => {
    const name = normName(miniName.value);
    const catId = String(miniCat.value || "misc");
    if(!name){
      showToast("Please enter a name", 1600);
      miniName.focus();
      return;
    }
    closeItemModal({ name, catId });
  };
  miniBg.onclick = e => { if(e.target === miniBg) closeItemModal(null); };

  // =========================
  // PHASE 2: Dish Ingredients Modal
  // =========================
  const dishBg = document.getElementById("dishBg");
  const dishTitle = document.getElementById("dishTitle");
  const dishIngList = document.getElementById("dishIngList");

  let dishEditingName = null;
  let dishEditingSnapshot = null;

  function buildCatSelect(selectedCatId){
    const sel = String(selectedCatId || "misc");
    const order = state.defaultOrder; // ingredient categories should be stable; default is fine
    const orderedCats = order.map(id => catById(id)).filter(Boolean);

    return `
      <select class="ingCat">
        ${orderedCats.map(c => `<option value="${escapeHtml(c.id)}" ${c.id===sel?"selected":""}>${escapeHtml(c.name)}</option>`).join("")}
      </select>
    `;
  }

  function addIngRow({name="", catId="misc"} = {}){
    const row = document.createElement("div");
    row.className = "ingRow";
    row.innerHTML = `
      <input class="ingName" type="text" placeholder="Ingredient name" value="${escapeHtml(name)}">
      ${buildCatSelect(catId || "misc")}
      <button class="delBtn" type="button" title="Remove">üóëÔ∏è</button>
    `;
    row.querySelector(".delBtn").onclick = () => row.remove();
    dishIngList.appendChild(row);
  }

  function getDishObjByName(name){
    const n = normName(name).toLowerCase();
    return (state.dishCatalog || []).find(d => normName(d.name).toLowerCase() === n) || null;
  }
  function hasDishObjByName(name){
    const n = normName(name).toLowerCase();
    return (state.dishCatalog || []).some(d => normName(d.name).toLowerCase() === n);
  }

  function openDishIngredientsModal(dishName){
    const dish = getDishObjByName(dishName);
    if(!dish){
      showToast("Dish not found in catalog.", 1600);
      return;
    }

    dishEditingName = dish.name;
    dishEditingSnapshot = JSON.stringify(dish.ingredients || []);

    dishTitle.textContent = `Ingredients: ${dish.name}`;
    dishIngList.innerHTML = "";

    const ings = Array.isArray(dish.ingredients) ? dish.ingredients : [];
    if(ings.length){
      ings.forEach(x => addIngRow({ name: x.name, catId: x.catId || "misc" }));
    }

    dishBg.style.display = "flex";
  }

  function closeDishModal(save){
    if(!dishEditingName){
      dishBg.style.display = "none";
      return;
    }

    const dish = getDishObjByName(dishEditingName);
    if(!dish){
      dishBg.style.display = "none";
      dishEditingName = null;
      return;
    }

    if(!save){
      try { dish.ingredients = JSON.parse(dishEditingSnapshot || "[]"); }
      catch { dish.ingredients = dish.ingredients || []; }
      dishBg.style.display = "none";
      dishEditingName = null;
      dishEditingSnapshot = null;
      return;
    }

    const out = [];
    dishIngList.querySelectorAll(".ingRow").forEach(r => {
      const n = normName(r.querySelector(".ingName")?.value || "");
      const cid = String(r.querySelector(".ingCat")?.value || "misc");
      if(!n) return;
      out.push({ name: n, catId: cid, catName: catNameFromId(cid) });
    });

    const seen = new Set();
    dish.ingredients = out.filter(x => {
      const k = normName(x.name).toLowerCase() + "|" + String(x.catId||"misc");
      if(seen.has(k)) return false;
      seen.add(k);
      return true;
    });

    saveState(LS_KEY, state);
    debouncedRender();

    dishBg.style.display = "none";
    dishEditingName = null;
    dishEditingSnapshot = null;

    showToast("Ingredients saved.", 1400);
  }

  document.getElementById("dishAddIng").onclick = () => addIngRow({name:"", catId:"misc"});
  document.getElementById("dishClose").onclick = () => closeDishModal(false);
  document.getElementById("dishCancel").onclick = () => closeDishModal(false);
  document.getElementById("dishSave").onclick = () => closeDishModal(true);
  dishBg.onclick = (e) => { if(e.target === dishBg) closeDishModal(false); };

  // =========================
  // Groceries: list + master
  // =========================
  let lastAddedId = null;
  let renderTimeout = null;

  function addItemToCurrent(name, catId="misc"){
    name = normName(name);
    catId = String(catId || "misc");
    if(!name) return false;

    const item = { id: generateId(), name, catId, catName: catNameFromId(catId), done:false, qty:"1", unit:"ea", price:"" };
    if(hasItem(state.current.items, item)) return false;

    state.current.items.push(item);
    lastAddedId = item.id;
    saveState(LS_KEY, state);
    debouncedRender();
    return true;
  }

  function deleteItemById(id) {
    const idx = state.current.items.findIndex(x => x.id === id);
    if (idx === -1) return;
    state.current.items.splice(idx, 1);
    if (lastAddedId === id) lastAddedId = null;
    saveState(LS_KEY, state);
    debouncedRender();
  }

  function updateItem(id, changes) {
    const item = state.current.items.find(x => x.id === id);
    if (!item) return;
    Object.assign(item, changes);

    // keep hybrid fields consistent if catId changes
    if("catId" in changes){
      item.catId = String(item.catId || "misc");
      item.catName = catNameFromId(item.catId);
    }

    saveState(LS_KEY, state);
    debouncedRender();
  }

  function addToMaster(name, catId="misc"){
    name = normName(name);
    catId = String(catId || "misc");
    if(!name) return false;

    const entry = { name, catId, catName: catNameFromId(catId) };
    if(hasItem(state.masterGroceries, entry)) return false;

    state.masterGroceries.push(entry);
    saveState(LS_KEY, state);
    debouncedRender();
    return true;
  }

  function removeFromMaster(name, catId){
    const n = normName(name).toLowerCase();
    const cid = String(catId || "misc");
    state.masterGroceries = state.masterGroceries.filter(x =>
      !(normName(x.name).toLowerCase()===n && String(x.catId||"misc")===cid)
    );
    saveState(LS_KEY, state);
    debouncedRender();
  }

  // =========================
  // Dishes
  // =========================
  function addDishToCatalogAndMenu(name){
    name = normName(name);
    if(!name) return {addedCatalog:false, addedMenu:false};

    let addedCatalog = false, addedMenu = false;

    if(!hasDishObjByName(name)){
      state.dishCatalog.push({ name, ingredients: [] });
      addedCatalog = true;
    }

    if(!hasDish(state.currentMenu, name)){
      state.currentMenu.push(name);
      addedMenu = true;
    }

    if(!state.menuAddFlags) state.menuAddFlags = {};
    state.menuAddFlags[name] = false;

    saveState(LS_KEY, state);
    debouncedRender();
    return {addedCatalog, addedMenu};
  }

  function removeDishFromMenu(name){
    const n = normName(name).toLowerCase();
    state.currentMenu = (state.currentMenu || []).filter(x => normName(x).toLowerCase() !== n);
    saveState(LS_KEY, state);
    debouncedRender();
  }

  function removeDishFromCatalog(name){
    const n = normName(name).toLowerCase();
    state.dishCatalog = (state.dishCatalog || []).filter(d => normName(d.name).toLowerCase() !== n);
    state.currentMenu = (state.currentMenu || []).filter(x => normName(x).toLowerCase() !== n);
    if(state.menuAddFlags) delete state.menuAddFlags[name];
    saveState(LS_KEY, state);
    debouncedRender();
  }

  function randomMenu14(){
    const pool = [...(state.dishCatalog || [])];
    for(let i=pool.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    state.currentMenu = pool.slice(0, 14).map(d => d.name);

    state.menuAddFlags = {};
    state.currentMenu.forEach(n => state.menuAddFlags[n] = false);

    saveState(LS_KEY, state);
    debouncedRender();
  }

  function debouncedRender() {
    clearTimeout(renderTimeout);
    renderTimeout = setTimeout(render, 60);
  }

  // =========================
  // Add Ingredients from checked menu dishes
  // =========================
  function addIngredientsForCheckedMenu(){
    let dishesChecked = 0;
    let ingAdded = 0;
    let ingAlready = 0;
    let ingMissing = 0;

    const menuRows = Array.from(document.querySelectorAll("#menuCard .dishRow"));

    const checkedMap = {};
    menuRows.forEach(row => {
      const key = row.dataset.key || "";
      const name = undishKey(key);
      const chk = row.querySelector(".ingCheck");
      checkedMap[name] = !!chk?.checked;
    });

    state.currentMenu.forEach(dishName => {
      const isChecked = Object.prototype.hasOwnProperty.call(checkedMap, dishName)
        ? checkedMap[dishName]
        : !!state.menuAddFlags?.[dishName];

      if(!isChecked) return;

      dishesChecked++;

      const dish = getDishObjByName(dishName);
      const ings = dish?.ingredients || [];
      if(!ings.length){
        ingMissing++;
        return;
      }

      ings.forEach(ing => {
        const n = normName(ing.name);
        const cid = String(ing.catId || "misc");
        if(!n) return;

        addToMaster(n, cid);

        const ok = addItemToCurrent(n, cid);
        if(ok){
          const it = state.current.items.find(x =>
            normName(x.name).toLowerCase()===n.toLowerCase()
            && String(x.catId||"misc")===cid
          );
          if(it){
            it.qty = "1";
            it.unit = "ea";
          }
          ingAdded++;
        } else {
          ingAlready++;
        }
      });
    });

    menuRows.forEach(row => {
      const chk = row.querySelector(".ingCheck");
      if(chk && chk.checked){
        chk.checked = false;
      }
      const name = undishKey(row.dataset.key || "");
      if(state.menuAddFlags && name) state.menuAddFlags[name] = false;
    });

    saveState(LS_KEY, state);
    debouncedRender();

    if(dishesChecked === 0){
      showToast("No dishes checked.", 1600);
      return;
    }

    const msg =
      `Checked dishes: ${dishesChecked} ‚Ä¢ Added: ${ingAdded}` +
      (ingAlready ? ` ‚Ä¢ Already: ${ingAlready}` : "") +
      (ingMissing ? ` ‚Ä¢ No ingredients: ${ingMissing}` : "");

    showToast(msg, 2600);
  }

  // =========================
  // Store sort indicator
  // =========================
  const sortIndicator = document.getElementById("sortIndicator");
  const sortIndicatorText = document.getElementById("sortIndicatorText");
  const btnClearStoreSort = document.getElementById("btnClearStoreSort");

  function updateSortIndicator(){
    const sid = state.activeStoreId || "__default__";
    const st = storeById(sid);

    if(sid === "__default__"){
      sortIndicator.style.display = "none";
      return;
    }

    sortIndicator.style.display = "flex";
    sortIndicatorText.textContent = `Sorted for: ${st.name}`;
  }

  btnClearStoreSort.onclick = () => {
    state.activeStoreId = "__default__";
    saveState(LS_KEY, state);
    debouncedRender();
    showToast("Sorting returned to Default.", 1400);
  };

  // =========================
  // Render
  // =========================
  function renderGroceries() {
    document.getElementById("listName").textContent = state.current.name;
    document.getElementById("total").textContent = money(computeTotal());
    updateSortIndicator();

    const sortedCurrent = [...state.current.items].sort(sortByStoreOrderThenName);
    const card = document.getElementById("listCard");

    if (sortedCurrent.length === 0) {
      card.innerHTML = `<div style="padding:16px; text-align:center;">
        <div class="muted">No items yet.</div>
        <div class="muted">Tap <b>SCAN QR</b>, <b>SCAN UPC</b>, or <b>Add Item</b>.</div>
      </div>`;
    } else {
      card.innerHTML = sortedCurrent.map(it => `
        <div class="item ${it.done ? "done":""}" data-id="${it.id}">
          <input class="check" type="checkbox" ${it.done ? "checked":""}>
          <div class="name">${escapeHtml(it.name)}</div>
          <span class="catPill">${escapeHtml(catNameFromId(it.catId||"misc"))}</span>
          <input class="qty" type="number" step="0.5" min="0" value="${escapeHtml(it.qty)}">
          <select class="unit">
            ${UNITS.map(u => `<option ${u===it.unit?"selected":""}>${escapeHtml(u)}</option>`).join("")}
          </select>
          <input class="price" type="number" step="0.01" min="0" placeholder="$" value="${escapeHtml(it.price)}">
          <button class="delBtn" title="Delete">üóëÔ∏è</button>
        </div>
      `).join("");

      card.querySelectorAll(".item").forEach(row => {
        const id = row.dataset.id;
        const item = state.current.items.find(x => x.id === id);
        if (!item) return;

        row.querySelector(".check").onchange = e => updateItem(id, { done: e.target.checked });

        row.querySelector(".qty").onchange = e => {
          let v = parseFloat(e.target.value) || 0;
          v = Math.max(0, Math.min(999, v));
          updateItem(id, { qty: String(v) });
        };

        row.querySelector(".unit").onchange = e => updateItem(id, { unit: e.target.value });

        row.querySelector(".price").onchange = e => {
          let v = parseFloat(e.target.value);
          updateItem(id, { price: isNaN(v) ? "" : String(Math.max(0, v)) });
        };

        row.querySelector(".delBtn").onclick = () => deleteItemById(id);

        row.querySelector(".name").onclick = async () => {
          const res = await openItemModal("Edit Item", { name: item.name, catId: item.catId || "misc" });
          if(!res) return;

          const cand = { name: res.name, catId: res.catId };
          const others = state.current.items.filter(x => x.id !== id);
          if(hasItem(others, cand)){
            showToast("That item already exists in the Shopping List.", 1900);
            return;
          }
          updateItem(id, { name: res.name, catId: res.catId });
        };
      });
    }

    // Master list
    const sortedMaster = [...state.masterGroceries].sort(sortByStoreOrderThenName);
    document.getElementById("masterCount").textContent = sortedMaster.length;

    const masterCard = document.getElementById("masterCard");
    if(sortedMaster.length === 0){
      masterCard.innerHTML = `<div style="padding:14px; text-align:center;">
        <div class="muted">Master list is empty.</div>
        <div class="muted">Scan QR/UPC or add items to build your master list.</div>
      </div>`;
    } else {
      masterCard.innerHTML = sortedMaster.map((m, idx) => `
        <div class="masterRow" data-idx="${idx}">
          <input class="mCheck" type="checkbox">
          <div class="mName">${escapeHtml(m.name)}</div>
          <span class="catPill">${escapeHtml(catNameFromId(m.catId||"misc"))}</span>
          <button class="delBtn" title="Delete from Master">üóëÔ∏è</button>
        </div>
      `).join("");

      const rows = Array.from(masterCard.querySelectorAll(".masterRow"));
      rows.forEach(row => {
        const idx = parseInt(row.dataset.idx, 10);
        const m = sortedMaster[idx];
        if(!m) return;

        row.querySelector(".mName").onclick = async () => {
          const res = await openItemModal("Edit Master Item", { name: m.name, catId: m.catId || "misc" });
          if(!res) return;
          removeFromMaster(m.name, m.catId || "misc");
          addToMaster(res.name, res.catId);
          showToast("Master item updated.", 1500);
        };

        row.querySelector(".delBtn").onclick = () => {
          const ok = confirm(`Delete from Master?\n\n${m.name} (${catNameFromId(m.catId||"misc")})`);
          if(!ok) return;
          removeFromMaster(m.name, m.catId || "misc");
        };
      });
    }
  }

  function dishRowHtml(name, where){
    const dish = getDishObjByName(name);
    const hasIng = !!(dish && Array.isArray(dish.ingredients) && dish.ingredients.length);

    const menuControls = (where === "menu") ? `
      <label style="display:flex;align-items:center;gap:8px; font-weight:900;">
        <input class="ingCheck" type="checkbox" ${state.menuAddFlags?.[name] ? "checked":""}>
        <span title="${hasIng ? "Has ingredients" : "No ingredients yet"}" style="font-size:18px; opacity:${hasIng ? "1":"0.35"};">üßÇ</span>
      </label>
    ` : `
      <span title="${hasIng ? "Has ingredients" : "No ingredients yet"}" style="font-size:18px; opacity:${hasIng ? "1":"0.35"};">üßÇ</span>
    `;

    return `
      <div class="dishRow" data-key="${dishKey(name)}" data-where="${where}">
        <div style="display:flex; align-items:center; gap:12px;">
          ${menuControls}
          <div class="dishName">${escapeHtml(name)}</div>
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          ${where==="menu" ? `<span class="pill ok">MENU</span>` : `<span class="pill">CATALOG</span>`}
          <button class="delBtn" title="Delete">üóëÔ∏è</button>
        </div>
      </div>
    `;
  }

  function renderDishes(){
    document.getElementById("menuCount").textContent = (state.currentMenu || []).length;
    document.getElementById("catalogCount").textContent = (state.dishCatalog || []).length;

    const menuCard = document.getElementById("menuCard");
    if(!state.currentMenu || state.currentMenu.length === 0){
      menuCard.innerHTML = `<div style="padding:16px; text-align:center;">
        <div class="muted">Menu is empty.</div>
        <div class="muted">Scan a dish QR or tap <b>Random Menu (14)</b>.</div>
      </div>`;
    } else {
      menuCard.innerHTML = state.currentMenu.map(d => dishRowHtml(d, "menu")).join("");
    }

    const catalogCard = document.getElementById("catalogCard");
    if(!state.dishCatalog || state.dishCatalog.length === 0){
      catalogCard.innerHTML = `<div style="padding:16px; text-align:center;">
        <div class="muted">Catalog is empty.</div>
        <div class="muted">Scan dish QR codes to build it.</div>
      </div>`;
    } else {
      catalogCard.innerHTML = state.dishCatalog.map(d => dishRowHtml(d.name, "catalog")).join("");
    }

    function bindDishRows(container){
      container.querySelectorAll(".dishRow").forEach(row=>{
        const name = undishKey(row.dataset.key || "");
        const where = row.dataset.where;

        const chk = row.querySelector(".ingCheck");
        if(chk){
          chk.checked = !!state.menuAddFlags?.[name];

          chk.onchange = (e) => {
            e.stopPropagation();
            if(!state.menuAddFlags) state.menuAddFlags = {};
            state.menuAddFlags[name] = !!chk.checked;
            saveState(LS_KEY, state);
          };

          chk.onclick = (e) => e.stopPropagation();
        }

        row.querySelector(".dishName").onclick = () => {
          if(where === "catalog"){
            addDishToCatalogAndMenu(name);
            return;
          }

          const allowed = !!row.querySelector(".ingCheck")?.checked;

          if(allowed){
            openDishIngredientsModal(name);
            return;
          }

          const newName = prompt("Rename dish (updates Catalog + Menu):", name);
          if(!newName) return;
          const nn = normName(newName);
          if(!nn) return;

          removeDishFromCatalog(name);
          addDishToCatalogAndMenu(nn);

          if(state.menuAddFlags){
            delete state.menuAddFlags[name];
            state.menuAddFlags[nn] = false;
            saveState(LS_KEY, state);
          }
        };

        row.querySelector(".delBtn").onclick = () => {
          if(where === "menu"){
            const choice = prompt(`Delete "${name}"?\nType:\nM = remove from Menu only\nC = remove from Catalog (also removes from Menu)\n(Anything else cancels)`, "M");
            if(!choice) return;
            const ch = choice.trim().toUpperCase();
            if(ch === "M") removeDishFromMenu(name);
            else if(ch === "C") removeDishFromCatalog(name);
          } else {
            const choice = prompt(`Delete "${name}"?\nType:\nC = remove from Catalog (also removes from Menu)\nM = remove from Menu only\n(Anything else cancels)`, "C");
            if(!choice) return;
            const ch = choice.trim().toUpperCase();
            if(ch === "C") removeDishFromCatalog(name);
            else if(ch === "M") removeDishFromMenu(name);
          }
        };
      });
    }

    bindDishRows(menuCard);
    bindDishRows(catalogCard);
  }

  function renderTools(){
    const deviceNameInput = document.getElementById("deviceName");
    if(deviceNameInput && deviceNameInput.value !== state.deviceName){
      deviceNameInput.value = state.deviceName || "";
    }
  }

  function render(){
    renderGroceries();
    renderDishes();
    renderTools();
    renderShopMenu(); // keep highlight in sync
  }

  // =========================
  // Tabs / Screens
  // =========================
  const tabGroceries = document.getElementById("tabGroceries");
  const tabDishes = document.getElementById("tabDishes");
  const screenGroceries = document.getElementById("screenGroceries");
  const screenDishes = document.getElementById("screenDishes");
  const screenTools = document.getElementById("screenTools");
  const btnMore = document.getElementById("btnMore");

  function showTab(which){
    const isG = which === "groceries";
    const isD = which === "dishes";
    const isT = which === "tools";

    screenGroceries.style.display = isG ? "" : "none";
    screenDishes.style.display   = isD ? "" : "none";
    screenTools.style.display    = isT ? "" : "none";

    tabGroceries.classList.toggle("active", isG);
    tabDishes.classList.toggle("active", isD);

    document.getElementById("btnClearDone").style.display = isG ? "" : "none";
    btnMore.style.display = isG ? "" : "none";
  }

  tabGroceries.onclick = () => showTab("groceries");
  tabDishes.onclick = () => showTab("dishes");

  btnMore.onclick = () => showTab("tools");
  document.getElementById("btnToolsBack").onclick = () => showTab("groceries");

  // =========================
  // Grocery actions
  // =========================
  document.getElementById("btnNew").onclick = () => {
    const name = prompt("List name?", state.current.name);
    if (!name?.trim()) return;
    state.current = newBlankList(name.trim());
    lastAddedId = null;
    saveState(LS_KEY, state);
    render();
  };

  document.getElementById("btnAdd").onclick = async () => {
    const res = await openItemModal("Add Item", { name:"", catId:"misc" });
    if(!res) return;

    addToMaster(res.name, res.catId);

    const also = confirm(`Add to Current Shopping List too?\n\n${res.name} (${catNameFromId(res.catId)})`);
    if(also){
      const ok = addItemToCurrent(res.name, res.catId);
      showToast(ok ? `Added: ${res.name}` : `Already in Shopping List: ${res.name}`, 1800);
    } else {
      showToast(`Added to Master only: ${res.name}`, 1800);
    }
  };

  document.getElementById("btnUndo").onclick = () => {
    if (lastAddedId) deleteItemById(lastAddedId);
  };

  document.getElementById("btnClearDone").onclick = () => {
    const before = state.current.items.length;
    state.current.items = state.current.items.filter(x => !x.done);
    if (state.current.items.length !== before) {
      saveState(LS_KEY, state);
      render();
    }
  };

  document.getElementById("btnMasterAddSelected").onclick = () => {
    const masterCard = document.getElementById("masterCard");
    const rows = Array.from(masterCard.querySelectorAll(".masterRow"));
    if(rows.length === 0) return;

    let added = 0;
    let already = 0;

    rows.forEach(r => {
      const cb = r.querySelector(".mCheck");
      if(!cb || !cb.checked) return;

      const name = r.querySelector(".mName")?.textContent || "";
      const catPill = r.querySelector(".catPill")?.textContent || "Misc";

      // Map pill name -> catId
      const cid = (state.categories.find(c => c.name.toLowerCase() === catPill.toLowerCase())?.id) || "misc";

      const ok = addItemToCurrent(name, cid);
      if(ok) added++; else already++;

      cb.checked = false;
    });

    if(added === 0 && already === 0){
      showToast("No items checked.", 1600);
    } else {
      const msg = `Added ${added} item(s)` + (already ? ` (${already} already in list)` : "");
      showToast(msg, 2200);
    }
  };

  document.getElementById("btnMasterClearChecks").onclick = () => {
    document.querySelectorAll("#masterCard .mCheck").forEach(cb => cb.checked = false);
    showToast("Master checks cleared.", 1400);
  };

  document.getElementById("btnMasterClear").onclick = () => {
    if(!confirm("Clear the entire Master Grocery List?")) return;
    state.masterGroceries = [];
    saveState(LS_KEY, state);
    render();
  };

  // =========================
  // Dish actions
  // =========================
  document.getElementById("btnRandom14").onclick = () => {
    if(!state.dishCatalog || state.dishCatalog.length === 0){
      alert("Catalog is empty. Scan some dish QR codes first.");
      return;
    }
    randomMenu14();
  };

  document.getElementById("btnAddCheckedIng").onclick = () => {
    addIngredientsForCheckedMenu();
  };

  document.getElementById("btnClearMenu").onclick = () => {
    if(!confirm("Clear the current menu?")) return;
    state.currentMenu = [];
    state.menuAddFlags = {};
    saveState(LS_KEY, state);
    render();
  };

  document.getElementById("btnClearCatalog").onclick = () => {
    if(!confirm("Clear the entire Dish Catalog AND Menu?")) return;
    state.dishCatalog = [];
    state.currentMenu = [];
    state.menuAddFlags = {};
    saveState(LS_KEY, state);
    render();
  };

  document.getElementById("btnAddDish").onclick = () => {
    const name = prompt("Enter dish name:");
    if (!name) return;
    const normalized = normName(name);
    if (!normalized) {
      showToast("Please enter a valid dish name", 1800);
      return;
    }
    const result = addDishToCatalogAndMenu(normalized);
    showToast((result.addedCatalog || result.addedMenu) ? `Added dish: ${normalized}` : `Already exists: ${normalized}`, 1800);
  };

  // =========================
  // Scanner logic (QR + UPC modes)
  // =========================
  const modalBg = document.getElementById("modalBg");
  const scanMsgEl = document.getElementById("scanMsg");
  const scanTitleEl = document.getElementById("scanTitle");
  const scanHintEl = document.getElementById("scanHint");
  let qr = null;

  let scanMode = "qr";
  let pending = null;
  let targetLocked = false;
  let audioCtx = null;

  function beep() {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine"; osc.frequency.value = 880;
      gain.gain.value = 0.06;
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start();
      setTimeout(() => osc.stop(), 90);
    } catch {}
  }

  function setScanMsg(text, cls = "") {
    scanMsgEl.textContent = text;
    scanMsgEl.className = "scanMsg" + (cls ? ` ${cls}` : "");
  }

  function resetTarget() {
    pending = null;
    targetLocked = false;
    document.getElementById("btnCapture").disabled = true;
    setScanMsg("Point camera at code ‚Äì hold steady‚Ä¶");
  }

  function parseQR(decodedText){
    let raw = String(decodedText ?? "");
    raw = raw.replace(/\uFEFF/g, "");
    raw = raw.replace(/\r\n/g, "\n").trim();
    raw = raw.slice(0, 2000);

    if(!raw) return { kind:"unknown", raw:"" };

    const maybeDecode = (s) => {
      s = String(s ?? "");
      if (/%[0-9A-Fa-f]{2}/.test(s)) {
        try { return decodeURIComponent(s); } catch {}
      }
      return s;
    };

    const lower = raw.toLowerCase();

    try {
      if (/^[a-z]+:\/\//i.test(raw)) {
        const url = new URL(raw);

        const dish = url.searchParams.get("dish");
        if (dish) return { kind:"dish", name: maybeDecode(dish).trim().slice(0,120), raw };

        const item = url.searchParams.get("item");
        const cat  = url.searchParams.get("cat");
        if (item) return {
          kind:"item",
          name: maybeDecode(item).trim().slice(0,120),
          cat:  maybeDecode(cat||"").trim().slice(0,80),
          raw
        };

        const text = url.searchParams.get("text");
        if (text) return parseQR(maybeDecode(text).trim());
      }
    } catch {}

    const dishMatch = raw.match(/(?:^|[?&\s])dish=([^&\n]+)/i);
    if (dishMatch) {
      const name = maybeDecode(dishMatch[1]).trim();
      return { kind:"dish", name: name.slice(0,120), raw };
    }

    const itemMatch = raw.match(/(?:^|[?&\s])item=([^&\n]+)/i);
    if (itemMatch) {
      const start = lower.indexOf("item=");
      const qs = raw.slice(start);
      const sp = new URLSearchParams(qs);
      const item = sp.get("item");
      const cat  = sp.get("cat");
      if (item) {
        return {
          kind:"item",
          name: maybeDecode(item).trim().slice(0,120),
          cat:  maybeDecode(cat||"").trim().slice(0,80),
          raw
        };
      }
    }

    return { kind:"unknown", raw: raw.slice(0,140) };
  }

  function parseUPC(decodedText){
    let raw = String(decodedText ?? "").trim();
    raw = raw.replace(/[^\d]/g, "");
    raw = raw.slice(0, 32);
    if(!raw) return { kind:"unknown", raw:"" };
    return { kind:"upc", code: raw, raw };
  }

  async function openScanner(mode){
    scanMode = mode;
    modalBg.style.display = "flex";
    resetTarget();
    document.getElementById("reader").innerHTML = "";

    scanTitleEl.textContent = (mode === "upc") ? "Scan UPC" : "Scan QR";
    scanHintEl.textContent  = (mode === "upc")
      ? "Tip: Center the barcode inside the rectangle and hold steady."
      : "Tip: Fill the square with the QR and hold steady.";

    const formats = (mode === "upc")
      ? [
          Html5QrcodeSupportedFormats.UPC_A,
          Html5QrcodeSupportedFormats.UPC_E,
          Html5QrcodeSupportedFormats.EAN_13,
          Html5QrcodeSupportedFormats.EAN_8,
          Html5QrcodeSupportedFormats.CODE_128
        ]
      : [Html5QrcodeSupportedFormats.QR_CODE];

    qr = new Html5Qrcode("reader", {
      verbose: false,
      formatsToSupport: formats,
      experimentalFeatures: { useBarCodeDetectorIfSupported: true }
    });

    try {
      const cameras = await Html5Qrcode.getCameras();
      if (!cameras?.length) throw new Error("No cameras found");

      const rear = cameras.find(c => /back|rear|environment/i.test(c.label)) || cameras[cameras.length-1];

      const qrboxFunction = () => {
        if(mode === "upc") return { width: 260, height: 110 };
        return { width: 70, height: 70 };
      };

      await qr.start(
        rear.id,
        {
          fps: 12,
          qrbox: qrboxFunction,
          disableFlip: false,
          rememberLastUsedCamera: true,
          aspectRatio: 1.777
        },
        onScanSuccess
      );
    } catch (err) {
      setScanMsg("Camera error ‚Äì check permissions / try again.", "warn");
      console.warn("Scanner start failed:", err);
      setTimeout(closeScanner, 2200);
    }
  }

  async function closeScanner() {
    modalBg.style.display = "none";
    resetTarget();

    if (!qr) return;
    try {
      await qr.stop();
      qr.clear();
    } catch (err) {
      console.warn("Scanner cleanup issue:", err);
    } finally {
      qr = null;
      document.getElementById("reader").innerHTML = "";
    }
  }

  function onScanSuccess(decodedText) {
    if (targetLocked) return;
    targetLocked = true;

    pending = (scanMode === "upc") ? parseUPC(decodedText) : parseQR(decodedText);

    if (navigator.vibrate) navigator.vibrate([30, 20, 30]);
    beep();

    document.getElementById("btnCapture").disabled = false;

    if(pending.kind === "dish"){
      setScanMsg(`Detected DISH: ${pending.name} ‚Üí tap Capture`, "ok");
    } else if(pending.kind === "item"){
      const cat = pending.cat ? ` (${pending.cat})` : "";
      setScanMsg(`Detected ITEM: ${pending.name}${cat} ‚Üí tap Capture`, "ok");
    } else if(pending.kind === "upc"){
      setScanMsg(`Detected UPC: ${pending.code} ‚Üí tap Capture`, "ok");
    } else {
      setScanMsg(`Detected: ${pending.raw} ‚Üí tap Capture`, "warn");
    }
  }

  document.getElementById("btnCapture").onclick = async () => {
    if (!pending) return;

    if(pending.kind === "dish"){
      const r = addDishToCatalogAndMenu(pending.name);
      setScanMsg((r.addedCatalog || r.addedMenu) ? `‚úÖ Dish added: ${pending.name}` : `‚ÑπÔ∏è Dish already exists: ${pending.name}`, "ok");
      showTab("dishes");
    }
    else if(pending.kind === "item"){
      // pending.cat is a NAME; map it to catId if possible, else create custom
      const catName = normName(pending.cat) || "Misc";
      let catId = (state.categories.find(c => c.name.toLowerCase() === catName.toLowerCase())?.id) || null;

      if(!catId){
        const base = slugIdFromName(catName);
        let nid = base, k=2;
        while(state.categories.some(c => c.id === nid)) nid = `${base}-${k++}`;
        state.categories.push({ id:nid, name: catName, builtIn:false });

        // add new cat to all orders (before misc)
        state.defaultOrder = insertBeforeMisc(state.defaultOrder, nid);
        Object.keys(state.storeOrders||{}).forEach(sid => {
          state.storeOrders[sid] = insertBeforeMisc(state.storeOrders[sid], nid);
        });

        catId = nid;
        saveState(LS_KEY, state);
      }

      addToMaster(pending.name, catId);
      const ok = addItemToCurrent(pending.name, catId);
      setScanMsg(ok ? `‚úÖ Added item: ${pending.name} (${catNameFromId(catId)})` : `‚ÑπÔ∏è Already in list: ${pending.name} (${catNameFromId(catId)})`, "ok");
      showTab("groceries");
    }
    else if(pending.kind === "upc"){
      const code = pending.code;

      const known = state.upcDB && state.upcDB[code];
      let entry = known ? { name: known.name, catId: known.catId || "misc" } : null;

      if(!entry){
        const res = await openItemModal("New UPC Item", { name:"", catId:"misc" });
        if(!res){
          setScanMsg("UPC captured, but canceled.", "warn");
          document.getElementById("btnCapture").disabled = true;
          setTimeout(resetTarget, 450);
          return;
        }
        entry = { name: res.name, catId: res.catId || "misc" };

        if(!state.upcDB) state.upcDB = {};
        state.upcDB[code] = { name: entry.name, catId: entry.catId, catName: catNameFromId(entry.catId) };
        saveState(LS_KEY, state);
      }

      addToMaster(entry.name, entry.catId);

      const also = confirm(`UPC: ${code}\n\nItem: ${entry.name} (${catNameFromId(entry.catId)})\n\nAdd to Current Shopping List too?`);
      if(also){
        const ok = addItemToCurrent(entry.name, entry.catId);
        setScanMsg(ok ? `‚úÖ Added: ${entry.name} (${catNameFromId(entry.catId)})` : `‚ÑπÔ∏è Already in list: ${entry.name} (${catNameFromId(entry.catId)})`, "ok");
      } else {
        setScanMsg(`‚úÖ Added to Master only: ${entry.name} (${catNameFromId(entry.catId)})`, "ok");
      }

      showTab("groceries");
    }
    else {
      const raw = normName(pending.raw);
      if(raw){
        addToMaster(raw, "misc");
        const also = confirm(`Detected unknown code:\n\n"${raw}"\n\nAdd to Current Shopping List too?`);
        if(also) addItemToCurrent(raw, "misc");
        setScanMsg(`‚úÖ Saved: ${raw}`, "ok");
        showTab("groceries");
      } else {
        setScanMsg("Nothing detected.", "warn");
      }
    }

    document.getElementById("btnCapture").disabled = true;
    setTimeout(resetTarget, 650);
  };

  document.getElementById("btnScan").onclick = () => openScanner("qr");
  document.getElementById("btnScanUPC").onclick = () => openScanner("upc");
  document.getElementById("btnScanDish").onclick = () => openScanner("qr");

  document.getElementById("btnCloseTop").onclick = closeScanner;
  document.getElementById("btnDone").onclick = closeScanner;
  modalBg.onclick = e => { if (e.target === modalBg) closeScanner(); };

  // =========================
  // SHOP: two-stage store menu
  // =========================
  const btnShop  = document.getElementById("btnShop");
  const shopMenu = document.getElementById("shopMenu");
  const shopSubMenu = document.getElementById("shopSubMenu");

  let shopSelectedStoreId = "__default__";

  function closeMenus(){
    shopMenu.classList.add("hidden");
    shopSubMenu.classList.add("hidden");
  }

  function openMainMenu(){
    shopSubMenu.classList.add("hidden");
    shopMenu.classList.remove("hidden");
  }

  function openSubMenu(storeId){
    shopSelectedStoreId = storeId;
    shopMenu.classList.add("hidden");
    shopSubMenu.classList.remove("hidden");
    renderShopSubMenu(storeId);
  }

  function renderShopMenu(){
    const active = state.activeStoreId || "__default__";

    shopMenu.innerHTML = STORES.map(s => {
      const cls = ["shopItem"];
      if(s.id === active && s.id !== "__default__") cls.push("active");
      if(s.id === "__default__" && active === "__default__") cls.push("active");
      return `<button class="${cls.join(" ")}" data-store="${escapeHtml(s.id)}" role="menuitem">${escapeHtml(s.name)}</button>`;
    }).join("");
  }

  function renderShopSubMenu(storeId){
    const st = storeById(storeId);

    const head = `
      <div class="shopSubHead">
        <button class="shopBackBtn" type="button" id="shopBack">‚Üê</button>
        <div style="flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
          ${escapeHtml(st.name)}
        </div>
      </div>
    `;

    const canSite = !!st.url && storeId !== "__default__";

    shopSubMenu.innerHTML = head + `
      <button class="shopItem" data-act="sort" role="menuitem">Sort</button>
      <button class="shopItem" data-act="edit" role="menuitem">Edit Order</button>
      ${canSite ? `<button class="shopItem" data-act="site" role="menuitem">Site</button>` : ``}
    `;

    document.getElementById("shopBack").onclick = (e) => {
      e.stopPropagation();
      openMainMenu();
    };
  }

  btnShop.addEventListener("click", (e) => {
    e.stopPropagation();
    // toggle main menu
    const isOpen = !shopMenu.classList.contains("hidden") || !shopSubMenu.classList.contains("hidden");
    if(isOpen) closeMenus();
    else {
      renderShopMenu();
      openMainMenu();
    }
  });

  shopMenu.addEventListener("click", (e) => {
    e.stopPropagation();
    const item = e.target.closest(".shopItem");
    if(!item) return;
    const sid = item.getAttribute("data-store") || "__default__";
    openSubMenu(sid);
  });

  shopSubMenu.addEventListener("click", (e) => {
    e.stopPropagation();
    const item = e.target.closest(".shopItem");
    if(!item) return;
    const act = item.getAttribute("data-act");
    const sid = shopSelectedStoreId || "__default__";
    const st = storeById(sid);

    if(act === "sort"){
      if(sid !== "__default__"){
        ensureStoreOrderExists(sid);
      }
      state.activeStoreId = sid; // remember active store (your choice B)
      saveState(LS_KEY, state);
      closeMenus();
      debouncedRender();
      showToast(`Sorted for: ${st.name}`, 1600);
      return;
    }

    if(act === "edit"){
      if(sid !== "__default__") ensureStoreOrderExists(sid);
      closeMenus();
      openCatsModalForStore(sid);
      return;
    }

    if(act === "site"){
      if(st.url) window.open(st.url, "_blank", "noopener,noreferrer");
      closeMenus();
      return;
    }
  });

  document.addEventListener("click", () => closeMenus());
  document.addEventListener("keydown", (e) => { if(e.key === "Escape") closeMenus(); });

  // =========================
  // CATS: Store-scoped Order Editor
  // =========================
  const catBg = document.getElementById("catBg");
  const catMgrList = document.getElementById("catMgrList");
  const catNewName = document.getElementById("catNewName");
  const catAddBtn = document.getElementById("catAddBtn");
  const catSave = document.getElementById("catSave");
  const catCancel = document.getElementById("catCancel");
  const catCloseX = document.getElementById("catCloseX");
  const catContextLine = document.getElementById("catContextLine");
  const catCopyDefaultBtn = document.getElementById("catCopyDefaultBtn");

  let catsEditingStoreId = "__default__"; // "__default__" or storeId
  let catsDraftOrder = []; // catId[]
  let catsSnapshot = null;

  function insertBeforeMisc(order, catId){
    order = Array.isArray(order) ? [...order] : [];
    if(order.includes(catId)) return order;
    const iMisc = order.indexOf("misc");
    if(iMisc === -1) return [...order, catId, "misc"];
    order.splice(iMisc, 0, catId);
    return order;
  }

  function openCatsModalForStore(storeId){
    catsEditingStoreId = storeId || "__default__";

    const st = storeById(catsEditingStoreId);
    catContextLine.textContent =
      (catsEditingStoreId === "__default__")
        ? "Editing order for: Default (All Stores)"
        : `Editing order for: ${st.name}`;

    // Copy Default button shown only when editing a specific store
    catCopyDefaultBtn.style.display = (catsEditingStoreId !== "__default__") ? "" : "none";

    const order = (catsEditingStoreId === "__default__")
      ? state.defaultOrder
      : (getOrderForStore(catsEditingStoreId) || state.defaultOrder);

    catsDraftOrder = [...order];
    catsSnapshot = JSON.stringify({
      categories: state.categories,
      defaultOrder: state.defaultOrder,
      storeOrders: state.storeOrders
    });

    renderCatsList();
    catBg.style.display = "flex";
    setTimeout(()=> catNewName.focus(), 120);
  }

  function closeCatsModal(save){
    if(!save){
      // restore snapshot
      try{
        const snap = JSON.parse(catsSnapshot || "{}");
        if(Array.isArray(snap.categories)) state.categories = snap.categories;
        if(Array.isArray(snap.defaultOrder)) state.defaultOrder = snap.defaultOrder;
        if(snap.storeOrders && typeof snap.storeOrders === "object") state.storeOrders = snap.storeOrders;
      } catch {}
      catBg.style.display = "none";
      catsEditingStoreId = "__default__";
      catsDraftOrder = [];
      catsSnapshot = null;
      debouncedRender();
      return;
    }

    // Save draft order into correct target
    if(catsEditingStoreId === "__default__"){
      state.defaultOrder = normalizeOrder(catsDraftOrder);
    } else {
      ensureStoreOrderExists(catsEditingStoreId);
      state.storeOrders[catsEditingStoreId] = normalizeOrder(catsDraftOrder);
    }

    // Ensure all orders include all cats
    state.defaultOrder = normalizeOrder(state.defaultOrder);
    Object.keys(state.storeOrders||{}).forEach(sid => {
      state.storeOrders[sid] = normalizeOrder(state.storeOrders[sid]);
    });

    saveState(LS_KEY, state);
    catBg.style.display = "none";
    catsEditingStoreId = "__default__";
    catsDraftOrder = [];
    catsSnapshot = null;
    debouncedRender();
    showToast("Category order saved.", 1400);
  }

  function normalizeOrder(order){
    const ids = state.categories.map(c => c.id);
    const seen = new Set();
    const out = [];

    (order || []).forEach(id => {
      id = String(id||"");
      if(!id) return;
      if(!ids.includes(id)) return;
      if(seen.has(id)) return;
      seen.add(id);
      out.push(id);
    });

    const hasMisc = out.includes("misc");
    const missing = ids.filter(id => id !== "misc" && !seen.has(id));
    if(missing.length){
      if(hasMisc){
        const iMisc = out.indexOf("misc");
        out.splice(iMisc, 0, ...missing);
      } else {
        out.push(...missing);
      }
    }

    if(!out.includes("misc")) out.push("misc");
    else {
      out.splice(out.indexOf("misc"), 1);
      out.push("misc");
    }
    return out;
  }

  function renderCatsList(){
    // Draft order -> rows
    const order = normalizeOrder(catsDraftOrder);
    catsDraftOrder = [...order];

    const rows = order.map(catId => {
      const c = catById(catId);
      const builtIn = !!c?.builtIn;
      const isMisc = catId === "misc";
      const delDisabled = builtIn || isMisc; // default cats not deletable; misc never deletable

      return `
        <div class="catMgrRow" draggable="true" data-id="${escapeHtml(catId)}">
          <div class="dragHandle" title="Drag to reorder">‚â°</div>
          <input class="catNameInput" type="text" value="${escapeHtml(c?.name || "Misc")}">
          <span class="catBadge ${builtIn ? "builtIn" : ""}">${builtIn ? "DEFAULT" : "CUSTOM"}</span>
          <button class="delBtn" title="Delete" ${delDisabled ? "disabled":""} style="${delDisabled ? "opacity:.45; cursor:not-allowed;" : ""}">üóëÔ∏è</button>
        </div>
      `;
    }).join("");

    catMgrList.innerHTML = rows;

    // Wire rename + delete
    catMgrList.querySelectorAll(".catMgrRow").forEach(row => {
      const catId = row.getAttribute("data-id");
      const input = row.querySelector(".catNameInput");
      const del = row.querySelector(".delBtn");

      input.addEventListener("change", () => {
        const newName = normName(input.value);
        if(!newName){
          input.value = catNameFromId(catId);
          return;
        }
        // prevent duplicate names
        const dup = state.categories.some(c => c.id !== catId && c.name.toLowerCase() === newName.toLowerCase());
        if(dup){
          showToast("Category name already exists.", 1600);
          input.value = catNameFromId(catId);
          return;
        }

        // rename in catalog
        const c = state.categories.find(x => x.id === catId);
        if(c){
          c.name = newName;
          // keep items' catName as display backup (not required, but nice)
          (state.current.items||[]).forEach(it => {
            if(String(it.catId||"misc") === catId) it.catName = newName;
          });
          (state.masterGroceries||[]).forEach(m => {
            if(String(m.catId||"misc") === catId) m.catName = newName;
          });
          (state.dishCatalog||[]).forEach(d => {
            (d.ingredients||[]).forEach(ing => {
              if(String(ing.catId||"misc") === catId) ing.catName = newName;
            });
          });
          saveState(LS_KEY, state);
        }
      });

      del.addEventListener("click", () => {
        if(del.disabled) return;
        const c = state.categories.find(x => x.id === catId);
        const ok = confirm(`Delete category "${c?.name}"?\n\nItems in this category will move to Misc.`);
        if(!ok) return;

        // move items to misc
        (state.current.items||[]).forEach(it => {
          if(String(it.catId||"misc") === catId){
            it.catId = "misc";
            it.catName = catNameFromId("misc");
          }
        });
        (state.masterGroceries||[]).forEach(m => {
          if(String(m.catId||"misc") === catId){
            m.catId = "misc";
            m.catName = catNameFromId("misc");
          }
        });
        (state.dishCatalog||[]).forEach(d => {
          (d.ingredients||[]).forEach(ing => {
            if(String(ing.catId||"misc") === catId){
              ing.catId = "misc";
              ing.catName = catNameFromId("misc");
            }
          });
        });

        // remove from catalog
        state.categories = state.categories.filter(x => x.id !== catId);

        // remove from orders
        state.defaultOrder = state.defaultOrder.filter(id => id !== catId);
        Object.keys(state.storeOrders||{}).forEach(sid => {
          state.storeOrders[sid] = (state.storeOrders[sid]||[]).filter(id => id !== catId);
        });

        // remove from draft
        catsDraftOrder = catsDraftOrder.filter(id => id !== catId);

        saveState(LS_KEY, state);
        renderCatsList();
        showToast("Category deleted (moved items to Misc).", 1800);
      });

      // Drag / drop reorder
      row.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData("text/plain", catId);
        e.dataTransfer.effectAllowed = "move";
      });

      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      row.addEventListener("drop", (e) => {
        e.preventDefault();
        const fromId = e.dataTransfer.getData("text/plain");
        const toId = catId;
        if(!fromId || !toId || fromId === toId) return;

        const arr = [...catsDraftOrder];
        const fromIdx = arr.indexOf(fromId);
        const toIdx = arr.indexOf(toId);
        if(fromIdx === -1 || toIdx === -1) return;

        arr.splice(fromIdx, 1);
        arr.splice(toIdx, 0, fromId);
        catsDraftOrder = arr;
        renderCatsList();
      });
    });
  }

  catAddBtn.onclick = () => {
    const name = normName(catNewName.value);
    if(!name){
      showToast("Enter a category name.", 1400);
      catNewName.focus();
      return;
    }

    const dup = state.categories.some(c => c.name.toLowerCase() === name.toLowerCase());
    if(dup){
      showToast("That category already exists.", 1600);
      catNewName.value = "";
      return;
    }

    // create new category
    const base = slugIdFromName(name);
    let nid = base, k=2;
    while(state.categories.some(c => c.id === nid)) nid = `${base}-${k++}`;

    state.categories.push({ id:nid, name, builtIn:false });

    // add to ALL orders (before misc)
    state.defaultOrder = insertBeforeMisc(state.defaultOrder, nid);
    Object.keys(state.storeOrders||{}).forEach(sid => {
      state.storeOrders[sid] = insertBeforeMisc(state.storeOrders[sid], nid);
    });

    // add to current draft order
    catsDraftOrder = insertBeforeMisc(catsDraftOrder, nid);

    saveState(LS_KEY, state);
    catNewName.value = "";
    renderCatsList();
    showToast("Category added.", 1400);
  };

  catCopyDefaultBtn.onclick = () => {
    if(catsEditingStoreId === "__default__") return;
    ensureStoreOrderExists(catsEditingStoreId);
    catsDraftOrder = [...state.defaultOrder];
    renderCatsList();
    showToast("Copied Default order into this store draft.", 1600);
  };

  catSave.onclick = () => closeCatsModal(true);
  catCancel.onclick = () => closeCatsModal(false);
  catCloseX.onclick = () => closeCatsModal(false);
  catBg.onclick = (e) => { if(e.target === catBg) closeCatsModal(false); };

  document.getElementById("btnCats").onclick = () => {
    // Default behavior: edit active store if one is selected, else default
    const sid = state.activeStoreId || "__default__";
    openCatsModalForStore(sid);
  };

  // =========================
  // TOOLS: Export / Import (MERGE)  (updated for v70 category model)
  // =========================
  const deviceNameInput = document.getElementById("deviceName");
  const importFileEl = document.getElementById("importFile");
  const importReportEl = document.getElementById("importReport");
  const impOverwriteUPC = document.getElementById("impOverwriteUPC");

  deviceNameInput.addEventListener("change", () => {
    state.deviceName = normName(deviceNameInput.value) || "My Device";
    saveState(LS_KEY, state);
    showToast("Device name saved.", 1400);
  });

  function nowStamp(){
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
  }

  function downloadJson(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 250);
  }

  function exportPayload(kind){
    const base = {
      app: "grocery-app",
      schema: 2, // v70 schema
      exportedAt: new Date().toISOString(),
      deviceName: state.deviceName || "",
      appVersion: APP_VERSION
    };

    const payloadCats = {
      categories: state.categories,
      defaultOrder: state.defaultOrder,
      storeOrders: state.storeOrders
    };

    const master = (state.masterGroceries || []).map(x => ({
      name: normName(x.name),
      catId: String(x.catId||"misc"),
      catName: normName(x.catName || catNameFromId(x.catId||"misc"))
    })).filter(x => x.name);

    const dishes = (state.dishCatalog || []).map(d => ({
      name: normName(d.name),
      ingredients: Array.isArray(d.ingredients) ? d.ingredients.map(i => ({
        name: normName(i.name),
        catId: String(i.catId||"misc"),
        catName: normName(i.catName || catNameFromId(i.catId||"misc"))
      })).filter(i=>i.name) : []
    })).filter(d => d.name);

    const upc = state.upcDB && typeof state.upcDB === "object" ? state.upcDB : {};

    if(kind === "master") return { ...base, kind, ...payloadCats, masterGroceries: master };
    if(kind === "dishes") return { ...base, kind, ...payloadCats, dishCatalog: dishes };
    if(kind === "upc") return { ...base, kind, ...payloadCats, upcDB: upc };

    return { ...base, kind: "all", ...payloadCats, masterGroceries: master, dishCatalog: dishes, upcDB: upc };
  }

  document.getElementById("btnExportAll").onclick = () => {
    const payload = exportPayload("all");
    const fn = `grocery-app_ALL_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported ALL.", 1600);
  };
  document.getElementById("btnExportMaster").onclick = () => {
    const payload = exportPayload("master");
    const fn = `grocery-app_MASTER_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported Master.", 1600);
  };
  document.getElementById("btnExportDishes").onclick = () => {
    const payload = exportPayload("dishes");
    const fn = `grocery-app_DISHES_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported Dishes.", 1600);
  };
  document.getElementById("btnExportUPC").onclick = () => {
    const payload = exportPayload("upc");
    const fn = `grocery-app_UPC_${normName(state.deviceName).replace(/\s+/g,"-")}_${nowStamp()}.json`;
    downloadJson(payload, fn);
    showToast("Exported UPC DB.", 1600);
  };

  document.getElementById("btnImport").onclick = () => {
    importFileEl.value = "";
    importFileEl.click();
  };

  function mergeCategoriesAndOrders(data){
    // Merge categories by ID; if ID conflicts with different name, keep local ID but update name to local (safer)
    const incCats = Array.isArray(data?.categories) ? data.categories : [];
    incCats.forEach(c => {
      const id = String(c?.id||"").trim();
      const name = normName(c?.name||"");
      const builtIn = !!c?.builtIn;
      if(!id || !name) return;

      const local = state.categories.find(x => x.id === id);
      if(!local){
        state.categories.push({ id, name, builtIn });
      } else {
        // keep local builtIn if true; update name if local not builtIn (or if same)
        if(!local.builtIn && name) local.name = name;
        local.builtIn = local.builtIn || builtIn;
      }
    });

    // Merge defaultOrder (union, prefer local order, append missing)
    const incDefault = Array.isArray(data?.defaultOrder) ? data.defaultOrder : null;
    if(incDefault){
      // union: keep local, ensure any incoming IDs exist in local order
      incDefault.forEach(id => {
        id = String(id||"");
        if(!id) return;
        if(!state.defaultOrder.includes(id) && state.categories.some(c => c.id === id)){
          state.defaultOrder = insertBeforeMisc(state.defaultOrder, id);
        }
      });
    }

    // Merge storeOrders
    const incStores = (data?.storeOrders && typeof data.storeOrders === "object") ? data.storeOrders : null;
    if(incStores){
      if(!state.storeOrders) state.storeOrders = {};
      Object.keys(incStores).forEach(sid => {
        const incOrder = Array.isArray(incStores[sid]) ? incStores[sid] : null;
        if(!incOrder) return;
        if(!state.storeOrders[sid]){
          state.storeOrders[sid] = normalizeOrder(incOrder);
        } else {
          // union incoming into local store order
          incOrder.forEach(id => {
            id = String(id||"");
            if(!id) return;
            if(state.categories.some(c => c.id === id) && !state.storeOrders[sid].includes(id)){
              state.storeOrders[sid] = insertBeforeMisc(state.storeOrders[sid], id);
            }
          });
          state.storeOrders[sid] = normalizeOrder(state.storeOrders[sid]);
        }
      });
    }

    // normalize after merge
    state.defaultOrder = normalizeOrder(state.defaultOrder);
    Object.keys(state.storeOrders||{}).forEach(sid => {
      state.storeOrders[sid] = normalizeOrder(state.storeOrders[sid]);
    });
  }

  function mergeMaster(imported){
    let added = 0, skipped = 0;
    const arr = Array.isArray(imported) ? imported : [];
    arr.forEach(x => {
      const name = normName(x?.name);
      const catId  = String(x?.catId || "misc");
      if(!name) return;

      // ensure category exists
      if(!state.categories.some(c => c.id === catId)){
        // fallback to misc if unknown
        addToMaster(name, "misc");
      } else {
        const ok = addToMaster(name, catId);
        if(ok) added++; else skipped++;
      }
    });
    return { added, skipped };
  }

  function mergeDishes(imported){
    let dishAdded = 0, dishUpdated = 0;
    let ingAdded = 0, ingSkipped = 0;

    const arr = Array.isArray(imported) ? imported : [];
    arr.forEach(d => {
      const dishName = normName(d?.name);
      if(!dishName) return;

      let local = getDishObjByName(dishName);
      if(!local){
        state.dishCatalog.push({ name: dishName, ingredients: [] });
        local = getDishObjByName(dishName);
        dishAdded++;
      }

      const incoming = Array.isArray(d?.ingredients) ? d.ingredients : [];
      const beforeCount = (local.ingredients || []).length;

      if(!Array.isArray(local.ingredients)) local.ingredients = [];

      const seen = new Set(local.ingredients.map(i =>
        normName(i.name).toLowerCase()+"|"+String(i.catId||"misc")
      ));

      incoming.forEach(i => {
        const inName = normName(i?.name);
        const inCatId  = String(i?.catId || "misc");
        if(!inName) return;

        const key = inName.toLowerCase()+"|"+inCatId;
        if(seen.has(key)){
          ingSkipped++;
          return;
        }
        seen.add(key);
        local.ingredients.push({ name: inName, catId: inCatId, catName: catNameFromId(inCatId) });
        ingAdded++;
      });

      if((local.ingredients || []).length !== beforeCount){
        dishUpdated++;
      }
    });

    return { dishAdded, dishUpdated, ingAdded, ingSkipped };
  }

  function mergeUPC(imported, overwrite){
    let added = 0, updated = 0, skipped = 0;
    if(!state.upcDB || typeof state.upcDB !== "object") state.upcDB = {};

    const obj = imported && typeof imported === "object" ? imported : {};
    Object.keys(obj).forEach(code => {
      const clean = String(code||"").replace(/[^\d]/g,"").slice(0,32);
      if(!clean) return;

      const incoming = obj[code];
      const name = normName(incoming?.name);
      const catId  = String(incoming?.catId || "misc");
      if(!name) return;

      const exists = state.upcDB[clean];
      if(!exists){
        state.upcDB[clean] = { name, catId, catName: catNameFromId(catId) };
        added++;
      } else {
        const same = normName(exists.name).toLowerCase()===name.toLowerCase()
          && String(exists.catId||"misc")===catId;

        if(same){
          skipped++;
        } else {
          if(overwrite){
            state.upcDB[clean] = { name, catId, catName: catNameFromId(catId) };
            updated++;
          } else {
            skipped++;
          }
        }
      }
    });

    return { added, updated, skipped };
  }

  importFileEl.addEventListener("change", async () => {
    const file = importFileEl.files?.[0];
    if(!file) return;

    try{
      const text = await file.text();
      const data = JSON.parse(text);

      const meta = {
        fromDevice: normName(data?.deviceName || "(unknown)"),
        exportedAt: data?.exportedAt || "(unknown)",
        kind: data?.kind || "(unknown)"
      };

      const doUPCOverwrite = !!impOverwriteUPC.checked;

      let report = "";
      report += `IMPORT FILE: ${file.name}\n`;
      report += `FROM DEVICE: ${meta.fromDevice}\n`;
      report += `EXPORTED AT: ${meta.exportedAt}\n`;
      report += `KIND: ${meta.kind}\n\n`;

      // merge cats/orders first
      mergeCategoriesAndOrders(data);
      report += `CATEGORIES/ORDERS:\n  Merged category catalog + default/store orders.\n\n`;

      const m = data?.masterGroceries ?? data?.master ?? null;
      const d = data?.dishCatalog ?? data?.dishes ?? null;
      const u = data?.upcDB ?? data?.upc ?? null;

      let masterRes = null, dishRes = null, upcRes = null;

      if(m){
        masterRes = mergeMaster(m);
        report += `MASTER MERGE:\n  Added: ${masterRes.added}\n  Skipped (already exists): ${masterRes.skipped}\n\n`;
      } else {
        report += `MASTER MERGE:\n  (No master data in file)\n\n`;
      }

      if(d){
        dishRes = mergeDishes(d);
        report += `DISH CATALOG MERGE:\n  New dishes: ${dishRes.dishAdded}\n  Dishes updated: ${dishRes.dishUpdated}\n  Ingredients added: ${dishRes.ingAdded}\n  Ingredients skipped: ${dishRes.ingSkipped}\n\n`;
      } else {
        report += `DISH CATALOG MERGE:\n  (No dish data in file)\n\n`;
      }

      if(u){
        upcRes = mergeUPC(u, doUPCOverwrite);
        report += `UPC DB MERGE:\n  Added: ${upcRes.added}\n  Updated: ${upcRes.updated}\n  Skipped: ${upcRes.skipped}\n  Policy: ${doUPCOverwrite ? "OVERWRITE conflicts" : "SKIP conflicts"}\n\n`;
      } else {
        report += `UPC DB MERGE:\n  (No upc data in file)\n\n`;
      }

      saveState(LS_KEY, state);
      debouncedRender();

      importReportEl.textContent = report.trim();
      showToast("Import merge complete.", 1800);

    } catch(err){
      console.warn("Import failed:", err);
      importReportEl.textContent = `Import failed.\n\n${String(err)}`;
      showToast("Import failed. Bad JSON?", 2000);
    }
  });

  // =========================
  // Initial render + default tab
  // =========================
  render();
  showTab("groceries");
  </script>
</body>
</html>
